{
    "admin_func/ban.py": {
        "hash": "d0fe519a7eb617a37cb0fef803b47ba3",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from disnake import Embed\n",
            "import json\n",
            "\n",
            "# Загружаем конфигурацию из JSON файла\n",
            "with open('conf/config.json', 'r') as f:\n",
            "    config = json.load(f)\n",
            "\n",
            "class Ban(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "\n",
            "    async def log_action(self, interaction, member, action):\n",
            "        \"\"\"Создает embed для логирования и отправляет его в лог-канал.\"\"\"\n",
            "        log_channel_id = config.get('ADMIN_LOG_CHANNEL', None)\n",
            "        log_channel = self.bot.get_channel(log_channel_id)\n",
            "\n",
            "        if log_channel:\n",
            "            try:\n",
            "                log_embed = disnake.Embed(\n",
            "                    title=\"Log\",\n",
            "                    color=disnake.Color.blue()\n",
            "                )\n",
            "                log_embed.add_field(name=\"Команда:\", value=action[\"command\"], inline=False)\n",
            "                log_embed.add_field(name=\"Заблокирован пользователь:\", value=member.mention, inline=False)\n",
            "                log_embed.add_field(name=\"Причина блокировки:\", value=action[\"reason\"], inline=False)\n",
            "                log_embed.set_thumbnail(url=member.avatar.url)\n",
            "                log_embed.set_footer(\n",
            "                    text=f\"Администратор: {interaction.user.display_name}\",\n",
            "                    icon_url=interaction.user.display_avatar.url\n",
            "                )\n",
            "                log_embed.timestamp = interaction.created_at\n",
            "\n",
            "                await log_channel.send(embed=log_embed)\n",
            "                print(f\"Лог отправлен: {action['command']} для пользователя {member.name}\")\n",
            "            except Exception as e:\n",
            "                print(f\"Ошибка при отправке лога: {e}\")\n",
            "                await interaction.followup.send(\"Не удалось отправить лог в канал.\", ephemeral=True)\n",
            "        else:\n",
            "            print(f\"Канал для логирования с ID {log_channel_id} не найден.\")\n",
            "            await interaction.followup.send(\"Канал для логирования не найден.\", ephemeral=True)\n",
            "\n",
            "    @commands.slash_command(name=\"user_ban\", description=\"Заблокировать пользователя.\")\n",
            "    async def ban(self, inter, member: disnake.Member, reason: str = \"По решению администрации\"):\n",
            "        \"\"\"Блокировка пользователя с указанием причины.\"\"\"\n",
            "        \n",
            "        # Проверка на наличие роли у пользователя, вызывающего команду\n",
            "        admin_roles = config.get('ADMIN', [])\n",
            "        if not any(role.id in admin_roles for role in inter.user.roles):\n",
            "            await inter.send(\"У вас нет прав для использования этой команды.\")\n",
            "            return\n",
            "\n",
            "        try:\n",
            "            await member.ban(reason=reason)\n",
            "\n",
            "            # Создаем красивый Embed для блокировки\n",
            "            embed = Embed(\n",
            "                title=\"Пользователь заблокирован\",\n",
            "                description=f\"Пользователь {member.mention} был заблокирован.\",\n",
            "                color=disnake.Color.red()\n",
            "            )\n",
            "            embed.set_thumbnail(url=member.avatar.url)\n",
            "            embed.add_field(name=\"Причина\", value=reason, inline=False)\n",
            "            embed.set_footer(text=f\"Администратор: {inter.user.name}\", icon_url=inter.user.avatar.url)\n",
            "            await inter.send(embed=embed)\n",
            "\n",
            "            # Логируем действие\n",
            "            action = {\n",
            "                \"command\": \"/user_ban\",           # Строка с командой\n",
            "                \"reason\": reason                  # Причина блокировки\n",
            "            }\n",
            "            await self.log_action(inter, member, action)  # Логируем действие\n",
            "\n",
            "        except Exception as e:\n",
            "            await inter.send(f\"Не удалось заблокировать пользователя: {e}\")\n",
            "\n",
            "# Добавляем Cog в бота\n",
            "def setup(bot):\n",
            "    bot.add_cog(Ban(bot))\n"
        ]
    },
    "admin_func/channel_lock.py": {
        "hash": "52dea91ceaf59387b0739d22852f0b0d",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "import json  # Импортируем json для чтения конфига\n",
            "\n",
            "class ChannelLock(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        with open(\"conf/config.json\", \"r\") as f:\n",
            "            self.config = json.load(f)\n",
            "\n",
            "    async def log_action(self, interaction, action):\n",
            "        \"\"\"Создает embed для логирования и отправляет его в лог-канал.\"\"\"\n",
            "        log_channel_id = self.config[\"ADMIN_LOG_CHANNEL\"]\n",
            "        log_channel = self.bot.get_channel(log_channel_id)\n",
            "\n",
            "        if log_channel:\n",
            "            try:\n",
            "                log_embed = disnake.Embed(\n",
            "                    title=\"Log\",\n",
            "                    color=disnake.Color.blue()\n",
            "                )\n",
            "                log_embed.add_field(name=\"Команда:\", value=f\"/{action}\", inline=False)\n",
            "                log_embed.set_thumbnail(url=interaction.user.display_avatar.url)\n",
            "                log_embed.set_footer(\n",
            "                    text=f\"Администратор: {interaction.user.display_name}\",\n",
            "                    icon_url=interaction.user.display_avatar.url\n",
            "                )\n",
            "                log_embed.timestamp = interaction.created_at\n",
            "\n",
            "                await log_channel.send(embed=log_embed)\n",
            "                print(f\"Лог отправлен: {action}\")\n",
            "            except Exception as e:\n",
            "                print(f\"Ошибка при отправке лога: {e}\")\n",
            "                # Если ошибка, попробуем отправить сообщение в общий канал\n",
            "                await interaction.followup.send(\"Не удалось отправить лог в канал.\", ephemeral=True)\n",
            "        else:\n",
            "            print(f\"Канал для логирования с ID {log_channel_id} не найден.\")\n",
            "            # Если канал не найден, отправим сообщение в общий канал\n",
            "            await interaction.followup.send(\"Канал для логирования не найден.\", ephemeral=True)\n",
            "\n",
            "    @commands.slash_command(name=\"server_lock_channel\", description=\"Закрыть канал для выбранной роли\")\n",
            "    async def lock_channel(\n",
            "        self, \n",
            "        interaction: disnake.ApplicationCommandInteraction, \n",
            "        channel: disnake.TextChannel, \n",
            "        role: disnake.Role\n",
            "    ):\n",
            "        \"\"\"Закрывает канал для выбранной роли\"\"\"\n",
            "        \n",
            "        # Проверка, что у пользователя есть нужная роль\n",
            "        if not any(r.id in self.config[\"ADMIN\"] for r in interaction.author.roles):\n",
            "            await interaction.response.send_message(\"У вас нет прав для использования этой команды.\", ephemeral=True)\n",
            "            return\n",
            "        \n",
            "        # Получаем разрешения для роли\n",
            "        permissions = channel.overwrites_for(role)\n",
            "        \n",
            "        # Блокируем канал для роли\n",
            "        permissions.send_messages = False\n",
            "        permissions.view_channel = False  # Роль не будет видеть канал\n",
            "\n",
            "        # Применяем изменения\n",
            "        await channel.set_permissions(role, overwrite=permissions)\n",
            "\n",
            "        # Создаем embed для подтверждения\n",
            "        embed = disnake.Embed(\n",
            "            title=\"Канал закрыт для роли!\",\n",
            "            description=f\"Канал {channel.mention} был закрыт для роли {role.mention}. Пользователи с этой ролью не могут отправлять сообщения и видеть канал.\",\n",
            "            color=disnake.Color.from_rgb(255, 182, 193)  # Нежный розовый цвет\n",
            "        )\n",
            "        \n",
            "        # Устанавливаем аватарку бота справа сверху\n",
            "        embed.set_thumbnail(url=self.bot.user.avatar.url)\n",
            "\n",
            "        # Устанавливаем footer с именем и аватаркой администратора, который использовал команду\n",
            "        embed.set_footer(text=f\"Администратор: {interaction.user.display_name}\", icon_url=interaction.user.display_avatar.url)\n",
            "\n",
            "        # Отправляем embed\n",
            "        await interaction.response.send_message(embed=embed)\n",
            "\n",
            "        # Логируем действие\n",
            "        await self.log_action(interaction, \"server_lock_channel\")\n",
            "\n",
            "    @commands.slash_command(name=\"server_unlock_channel\", description=\"Открыть канал для выбранной роли\")\n",
            "    async def unlock_channel(\n",
            "        self, \n",
            "        interaction: disnake.ApplicationCommandInteraction, \n",
            "        channel: disnake.TextChannel, \n",
            "        role: disnake.Role\n",
            "    ):\n",
            "        \"\"\"Открывает канал для выбранной роли\"\"\"\n",
            "        \n",
            "        # Проверка, что у пользователя есть нужная роль\n",
            "        if not any(r.id in self.config[\"ADMIN\"] for r in interaction.author.roles):\n",
            "            await interaction.response.send_message(\"У вас нет прав для использования этой команды.\", ephemeral=True)\n",
            "            return\n",
            "        \n",
            "        # Получаем разрешения для роли\n",
            "        permissions = channel.overwrites_for(role)\n",
            "        \n",
            "        # Разблокируем канал для роли\n",
            "        permissions.send_messages = True\n",
            "        permissions.view_channel = True  # Роль будет видеть канал\n",
            "\n",
            "        # Применяем изменения\n",
            "        await channel.set_permissions(role, overwrite=permissions)\n",
            "\n",
            "        # Создаем embed для подтверждения\n",
            "        embed = disnake.Embed(\n",
            "            title=\"Канал открыт для роли!\",\n",
            "            description=f\"Канал {channel.mention} был открыт для роли {role.mention}. Пользователи с этой ролью теперь могут отправлять сообщения и видеть канал.\",\n",
            "            color=disnake.Color.from_rgb(255, 182, 193)  # Нежный розовый цвет\n",
            "        )\n",
            "        \n",
            "        # Устанавливаем аватарку бота справа сверху\n",
            "        embed.set_thumbnail(url=self.bot.user.avatar.url)\n",
            "\n",
            "        # Устанавливаем footer с именем и аватаркой администратора, который использовал команду\n",
            "        embed.set_footer(text=f\"Администратор: {interaction.user.display_name}\", icon_url=interaction.user.display_avatar.url)\n",
            "\n",
            "        # Отправляем embed\n",
            "        await interaction.response.send_message(embed=embed)\n",
            "\n",
            "        # Логируем действие\n",
            "        await self.log_action(interaction, \"server_unlock_channel\")\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(ChannelLock(bot))\n"
        ]
    },
    "admin_func/mute.py": {
        "hash": "6e94c345d07b6a061e4b78e21b7165f3",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from disnake import Embed\n",
            "import datetime\n",
            "import asyncio  # Мы добавляем asyncio для работы с асинхронными задержками\n",
            "import json\n",
            "\n",
            "# Загружаем конфигурацию из JSON файла\n",
            "with open('conf/config.json', 'r') as f:\n",
            "    config = json.load(f)\n",
            "\n",
            "class Mute(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        self.mute_role_id = config.get('MuteRole')  # ID роли мьюта\n",
            "        self.allowed_roles = config.get('ADMIN', [])  # ID ролей, которые могут использовать команду мьют\n",
            "\n",
            "    async def log_action(self, interaction, member, action, duration=None):\n",
            "        \"\"\"Создает embed для логирования и отправляет его в лог-канал.\"\"\"\n",
            "        log_channel_id = config.get('ADMIN_LOG_CHANNEL')\n",
            "        log_channel = self.bot.get_channel(log_channel_id)\n",
            "\n",
            "        if log_channel:\n",
            "            try:\n",
            "                log_embed = disnake.Embed(\n",
            "                    title=\"Log\",\n",
            "                    color=disnake.Color.blue()\n",
            "                )\n",
            "                log_embed.add_field(name=\"Команда:\", value=action[\"command\"], inline=False)\n",
            "                log_embed.add_field(name=\"Пользователь:\", value=member.mention, inline=False)\n",
            "                log_embed.add_field(name=\"Причина:\", value=action[\"reason\"], inline=False)\n",
            "                if duration:\n",
            "                    log_embed.add_field(name=\"Срок мьюта:\", value=duration, inline=False)\n",
            "                log_embed.set_thumbnail(url=member.avatar.url)\n",
            "                log_embed.set_footer(\n",
            "                    text=f\"Администратор: {interaction.user.display_name}\",\n",
            "                    icon_url=interaction.user.display_avatar.url\n",
            "                )\n",
            "                log_embed.timestamp = interaction.created_at\n",
            "\n",
            "                await log_channel.send(embed=log_embed)\n",
            "                print(f\"Лог отправлен: {action['command']} для пользователя {member.name}\")\n",
            "            except Exception as e:\n",
            "                print(f\"Ошибка при отправке лога: {e}\")\n",
            "                await interaction.followup.send(\"Не удалось отправить лог в канал.\", ephemeral=True)\n",
            "        else:\n",
            "            print(f\"Канал для логирования с ID {log_channel_id} не найден.\")\n",
            "            await interaction.followup.send(\"Канал для логирования не найден.\", ephemeral=True)\n",
            "\n",
            "    @commands.slash_command(name=\"user_mute\", description=\"Замутить пользователя на определенный срок.\")\n",
            "    async def mute(self, inter, member: disnake.Member, duration: str, reason: str = \"По решению администрации\"):\n",
            "        \"\"\"Выдача роли мьюта на указанное время.\"\"\"\n",
            "        # Проверка на наличие роли у пользователя, вызывающего команду\n",
            "        if not any(role.id in self.allowed_roles for role in inter.user.roles):\n",
            "            await inter.send(\"У вас нет прав для использования этой команды.\")\n",
            "            return\n",
            "\n",
            "        # Проверяем, есть ли у пользователя роль мьюта\n",
            "        mute_role = inter.guild.get_role(self.mute_role_id)\n",
            "        if mute_role in member.roles:\n",
            "            await inter.send(f\"{member.mention} уже замьючен!\")\n",
            "            return\n",
            "\n",
            "        # Преобразуем строку в объект времени (например, '1m', '2h', '3d')\n",
            "        try:\n",
            "            duration_timedelta = self.convert_duration_to_timedelta(duration)\n",
            "        except ValueError:\n",
            "            await inter.send(\"Неверный формат времени. Пример: 1m (минута), 2h (час), 3d (день).\")\n",
            "            return\n",
            "\n",
            "        # Выдаем роль мьюта\n",
            "        await member.add_roles(mute_role)\n",
            "        unmute_time = datetime.datetime.utcnow() + duration_timedelta\n",
            "\n",
            "        # Создаем Embed сообщение о мьюте\n",
            "        embed = Embed(\n",
            "            title=\"Пользователь замучен\",\n",
            "            description=f\"Пользователь {member.mention} был замьючен на {duration}.\",\n",
            "            color=disnake.Color.red()\n",
            "        )\n",
            "        embed.set_thumbnail(url=member.avatar.url)  # Аватар участника справа сверху\n",
            "        embed.add_field(name=\"Срок мьюта\", value=f\"До {unmute_time.strftime('%Y-%m-%d %H:%M:%S UTC')}\")\n",
            "        embed.add_field(name=\"Причина\", value=reason)  # Добавляем причину мьюта\n",
            "        embed.set_footer(text=f\"Администратор: {inter.user.name}\", icon_url=inter.user.avatar.url)  # Администратор в footer с аватаром\n",
            "        await inter.send(embed=embed)\n",
            "\n",
            "        # Логируем действие\n",
            "        action = {\n",
            "            \"command\": \"/user_mute\",   # Строка с командой\n",
            "            \"reason\": reason           # Причина мьюта\n",
            "        }\n",
            "        await self.log_action(inter, member, action, unmute_time.strftime('%Y-%m-%d %H:%M:%S UTC'))  # Логируем действие\n",
            "\n",
            "        # Устанавливаем задачу для размьюта через определенное время\n",
            "        await asyncio.sleep(duration_timedelta.total_seconds())\n",
            "        await member.remove_roles(mute_role)\n",
            "\n",
            "        # Отправляем уведомление о размьюте\n",
            "        embed = Embed(\n",
            "            title=\"Пользователь размучен\",\n",
            "            description=f\"Пользователь {member.mention} был размьючен.\",\n",
            "            color=disnake.Color.green()\n",
            "        )\n",
            "        embed.set_thumbnail(url=member.avatar.url)  # Аватар участника справа сверху\n",
            "        embed.set_footer(text=f\"Администратор: {inter.user.name}\", icon_url=inter.user.avatar.url)  # Администратор в footer с аватаром\n",
            "        await inter.send(embed=embed)\n",
            "\n",
            "    @commands.slash_command(name=\"user_unmute\", description=\"Размутить пользователя.\")\n",
            "    async def unmute(self, inter, member: disnake.Member):\n",
            "        \"\"\"Удалить роль мьюта.\"\"\"\n",
            "        # Проверка на наличие роли у пользователя, вызывающего команду\n",
            "        if not any(role.id in self.allowed_roles for role in inter.user.roles):\n",
            "            await inter.send(\"У вас нет прав для использования этой команды.\")\n",
            "            return\n",
            "\n",
            "        mute_role = inter.guild.get_role(self.mute_role_id)\n",
            "        if mute_role not in member.roles:\n",
            "            await inter.send(f\"{member.mention} не замьючен!\")\n",
            "            return\n",
            "\n",
            "        # Убираем роль мьюта\n",
            "        await member.remove_roles(mute_role)\n",
            "\n",
            "        # Создаем Embed сообщение о размьюте\n",
            "        embed = Embed(\n",
            "            title=\"Пользователь размучен\",\n",
            "            description=f\"Пользователь {member.mention} был размьючен.\",\n",
            "            color=disnake.Color.green()\n",
            "        )\n",
            "        embed.set_thumbnail(url=member.avatar.url)  # Аватар участника справа сверху\n",
            "        embed.set_footer(text=f\"Администратор: {inter.user.name}\", icon_url=inter.user.avatar.url)  # Администратор в footer с аватаром\n",
            "        await inter.send(embed=embed)\n",
            "\n",
            "        # Логируем действие\n",
            "        action = {\n",
            "            \"command\": \"/user_unmute\",   # Строка с командой\n",
            "            \"reason\": \"Нет\"              # Причина (уничтожение роли мьюта)\n",
            "        }\n",
            "        await self.log_action(inter, member, action)  # Логируем действие\n",
            "\n",
            "    def convert_duration_to_timedelta(self, duration: str):\n",
            "        \"\"\"Конвертировать строку в объект timedelta для времени.\"\"\"\n",
            "        if duration.endswith(\"m\"):\n",
            "            return datetime.timedelta(minutes=int(duration[:-1]))\n",
            "        elif duration.endswith(\"h\"):\n",
            "            return datetime.timedelta(hours=int(duration[:-1]))\n",
            "        elif duration.endswith(\"d\"):\n",
            "            return datetime.timedelta(days=int(duration[:-1]))\n",
            "        else:\n",
            "            raise ValueError(\"Неверный формат времени.\")\n",
            "\n",
            "# Добавляем Cog в бота\n",
            "def setup(bot):\n",
            "    bot.add_cog(Mute(bot))\n"
        ]
    },
    "admin_func/nickname.py": {
        "hash": "37a10f82f8af0a061c5d10773ce0eff8",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "import json\n",
            "\n",
            "# Загружаем конфигурацию из JSON файла\n",
            "with open('conf/config.json', 'r') as f:\n",
            "    config = json.load(f)\n",
            "\n",
            "class Nickname(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "\n",
            "    async def log_action(self, interaction, member, action):\n",
            "        \"\"\"Создает embed для логирования и отправляет его в лог-канал.\"\"\"\n",
            "        log_channel_id = config.get('ADMIN_LOG_CHANNEL')\n",
            "        log_channel = self.bot.get_channel(log_channel_id)\n",
            "\n",
            "        if log_channel:\n",
            "            try:\n",
            "                log_embed = disnake.Embed(\n",
            "                    title=\"Log\",\n",
            "                    color=disnake.Color.blue()\n",
            "                )\n",
            "                log_embed.add_field(name=\"Команда:\", value=action[\"command\"], inline=False)\n",
            "                log_embed.add_field(name=\"Пользователь:\", value=member.mention, inline=False)\n",
            "                log_embed.add_field(name=\"Новый никнейм:\", value=action[\"new_nickname\"], inline=False)\n",
            "                log_embed.set_thumbnail(url=member.display_avatar.url)\n",
            "                log_embed.set_footer(\n",
            "                    text=f\"Администратор: {interaction.user.display_name}\",\n",
            "                    icon_url=interaction.user.display_avatar.url\n",
            "                )\n",
            "                log_embed.timestamp = interaction.created_at\n",
            "\n",
            "                await log_channel.send(embed=log_embed)\n",
            "                print(f\"Лог отправлен: {action['command']} для пользователя {member.name}\")\n",
            "            except Exception as e:\n",
            "                print(f\"Ошибка при отправке лога: {e}\")\n",
            "                await interaction.followup.send(\"Не удалось отправить лог в канал.\", ephemeral=True)\n",
            "        else:\n",
            "            print(f\"Канал для логирования с ID {log_channel_id} не найден.\")\n",
            "            await interaction.followup.send(\"Канал для логирования не найден.\", ephemeral=True)\n",
            "\n",
            "    @commands.slash_command(name=\"user_change_nickname\", description=\"Изменить никнейм выбранного участника\")\n",
            "    async def change_nickname(\n",
            "        self, \n",
            "        interaction: disnake.ApplicationCommandInteraction, \n",
            "        member: disnake.Member, \n",
            "        new_nickname: str\n",
            "    ):\n",
            "        \"\"\"Изменяет никнейм выбранного участника и отправляет embed с подтверждением\"\"\"\n",
            "        \n",
            "        # Меняем никнейм участника\n",
            "        await member.edit(nick=new_nickname)\n",
            "        \n",
            "        # Создаем embed для подтверждения\n",
            "        embed = disnake.Embed(\n",
            "            title=\"Никнейм успешно изменен\",\n",
            "            description=f'Параметры участника {member.mention} были успешно изменены',\n",
            "            color=disnake.Color.from_rgb(255, 182, 193)  # Нежный розовый цвет\n",
            "        )\n",
            "        \n",
            "        # Устанавливаем аватарку участника справа сверху\n",
            "        embed.set_thumbnail(url=member.display_avatar.url)\n",
            "        \n",
            "        # Устанавливаем footer с именем и аватаркой администратора, который использовал команду\n",
            "        embed.set_footer(text=f\"Администратор: {interaction.user.display_name}\", icon_url=interaction.user.display_avatar.url)\n",
            "\n",
            "        # Отправляем embed\n",
            "        await interaction.response.send_message(embed=embed)\n",
            "\n",
            "        # Логируем действие\n",
            "        action = {\n",
            "            \"command\": \"/user_change_nickname\",   # Строка с командой\n",
            "            \"new_nickname\": new_nickname          # Новый никнейм\n",
            "        }\n",
            "        await self.log_action(interaction, member, action)  # Логируем действие\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(Nickname(bot))\n"
        ]
    },
    "admin_func/purge.py": {
        "hash": "087a9d98abeb144fd2734ddfdfddaf28",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "import json\n",
            "import os\n",
            "\n",
            "class ClearMessages(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        self.base_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n",
            "        self.config_path = os.path.join(self.base_path, \"conf/config.json\")\n",
            "        with open(self.config_path, 'r') as f:\n",
            "            self.config = json.load(f)\n",
            "\n",
            "    async def log_action(self, interaction, channel, action):\n",
            "        \"\"\"Создает embed для логирования и отправляет его в лог-канал.\"\"\"\n",
            "        log_channel_id = self.config[\"ADMIN_LOG_CHANNEL\"]\n",
            "        log_channel = self.bot.get_channel(log_channel_id)\n",
            "\n",
            "        if log_channel:\n",
            "            try:\n",
            "                log_embed = disnake.Embed(\n",
            "                    title=\"Log\",\n",
            "                    color=disnake.Color.blue()\n",
            "                )\n",
            "                log_embed.add_field(name=\"Команда:\", value=action[\"command\"], inline=False)\n",
            "                log_embed.add_field(name=\"Канал:\", value=channel.mention, inline=False)\n",
            "                log_embed.add_field(name=\"Удалено сообщений:\", value=str(action[\"deleted_count\"]), inline=False)\n",
            "                log_embed.set_thumbnail(url=interaction.user.display_avatar.url)\n",
            "                log_embed.set_footer(\n",
            "                    text=f\"Администратор: {interaction.user.display_name}\",\n",
            "                    icon_url=interaction.user.display_avatar.url\n",
            "                )\n",
            "                log_embed.timestamp = interaction.created_at\n",
            "\n",
            "                await log_channel.send(embed=log_embed)\n",
            "                print(f\"Лог отправлен: {action['command']} для канала {channel.name}\")\n",
            "            except Exception as e:\n",
            "                print(f\"Ошибка при отправке лога: {e}\")\n",
            "                # Если ошибка, попробуем отправить сообщение в общий канал\n",
            "                await interaction.followup.send(\"Не удалось отправить лог в канал.\", ephemeral=True)\n",
            "        else:\n",
            "            print(f\"Канал для логирования с ID {log_channel_id} не найден.\")\n",
            "            # Если канал не найден, отправим сообщение в общий канал\n",
            "            await interaction.followup.send(\"Канал для логирования не найден.\", ephemeral=True)\n",
            "\n",
            "    @commands.slash_command(name=\"clear\", description=\"Удалить указанное количество сообщений в канале\")\n",
            "    async def clear(\n",
            "        self, \n",
            "        interaction: disnake.ApplicationCommandInteraction, \n",
            "        channel: disnake.TextChannel, \n",
            "        amount: int\n",
            "    ):\n",
            "        \"\"\"Удаляет указанное количество сообщений в выбранном канале\"\"\"\n",
            "        \n",
            "        # Проверка, что у пользователя есть нужная роль\n",
            "        if not any(role.id in self.config[\"ADMIN\"] for role in interaction.author.roles):\n",
            "            await interaction.response.send_message(\"У вас нет прав для использования этой команды.\", ephemeral=True)\n",
            "            return\n",
            "        \n",
            "        # Проверка на допустимое количество сообщений (от 1 до 100)\n",
            "        if amount < 1 or amount > 100:\n",
            "            await interaction.response.send_message(\"Количество сообщений должно быть от 1 до 100.\", ephemeral=True)\n",
            "            return\n",
            "        \n",
            "        # Удаляем сообщения\n",
            "        deleted = await channel.purge(limit=amount)\n",
            "\n",
            "        # Создаем embed для подтверждения\n",
            "        embed = disnake.Embed(\n",
            "            title=\"Канал очищен!\",\n",
            "            description=f\"В канале {channel.mention} было удалено {len(deleted)} сообщений.\",\n",
            "            color=disnake.Color.from_rgb(255, 182, 193)  # Нежный розовый цвет\n",
            "        )\n",
            "        \n",
            "        # Устанавливаем аватарку бота справа сверху\n",
            "        embed.set_thumbnail(url=self.bot.user.avatar.url)\n",
            "\n",
            "        # Устанавливаем footer с именем и аватаркой администратора, который использовал команду\n",
            "        embed.set_footer(text=f\"Администратор: {interaction.user.display_name}\", icon_url=interaction.user.display_avatar.url)\n",
            "\n",
            "        # Отправляем embed с подтверждением\n",
            "        await interaction.response.send_message(embed=embed)\n",
            "\n",
            "        # Логируем действие\n",
            "        action = {\n",
            "            \"command\": \"/clear\",           # Строка с командой\n",
            "            \"deleted_count\": len(deleted)  # Количество удаленных сообщений\n",
            "        }\n",
            "        await self.log_action(interaction, channel, action)  # Теперь передаем словарь\n",
            "        \n",
            "def setup(bot):\n",
            "    bot.add_cog(ClearMessages(bot))\n"
        ]
    },
    "admin_func/role.py": {
        "hash": "bc98382ebf10117cc3b9495bed20caf4",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "import json\n",
            "\n",
            "# Загружаем конфигурацию из JSON файла\n",
            "with open('conf/config.json', 'r') as f:\n",
            "    config = json.load(f)\n",
            "\n",
            "class RoleManagement(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "\n",
            "    async def log_action(self, interaction, member, role, action):\n",
            "        \"\"\"Создает embed для логирования и отправляет его в лог-канал.\"\"\"\n",
            "        log_channel_id = config.get('ADMIN_LOG_CHANNEL', None)\n",
            "        log_channel = self.bot.get_channel(log_channel_id)\n",
            "\n",
            "        if log_channel:\n",
            "            try:\n",
            "                log_embed = disnake.Embed(\n",
            "                    title=\"Log\",\n",
            "                    color=disnake.Color.blue()\n",
            "                )\n",
            "                log_embed.add_field(name=\"Команда:\", value=action[\"command\"], inline=False)\n",
            "                log_embed.add_field(name=\"Пользователь:\", value=member.mention, inline=False)\n",
            "                log_embed.add_field(name=\"Роль:\", value=role.mention, inline=False)\n",
            "                log_embed.set_thumbnail(url=member.display_avatar.url)\n",
            "                log_embed.set_footer(\n",
            "                    text=f\"Администратор: {interaction.user.display_name}\",\n",
            "                    icon_url=interaction.user.display_avatar.url\n",
            "                )\n",
            "                log_embed.timestamp = interaction.created_at\n",
            "\n",
            "                await log_channel.send(embed=log_embed)\n",
            "                print(f\"Лог отправлен: {action['command']} для пользователя {member.name}\")\n",
            "            except Exception as e:\n",
            "                print(f\"Ошибка при отправке лога: {e}\")\n",
            "                await interaction.followup.send(\"Не удалось отправить лог в канал.\", ephemeral=True)\n",
            "        else:\n",
            "            print(f\"Канал для логирования с ID {log_channel_id} не найден.\")\n",
            "            await interaction.followup.send(\"Канал для логирования не найден.\", ephemeral=True)\n",
            "\n",
            "    @commands.slash_command(name=\"user_role_add\", description=\"Добавить роль выбранному участнику\")\n",
            "    async def user_role_add(\n",
            "        self, \n",
            "        interaction: disnake.ApplicationCommandInteraction, \n",
            "        member: disnake.Member, \n",
            "        role: disnake.Role\n",
            "    ):\n",
            "        \"\"\"Добавляет роль участнику и отправляет embed с подтверждением\"\"\"\n",
            "        \n",
            "        # Проверка, что у пользователя есть нужная роль\n",
            "        admin_roles = config.get('ADMIN', [])\n",
            "        if not any(r.id in admin_roles for r in interaction.author.roles):\n",
            "            await interaction.response.send_message(\"У вас нет прав для использования этой команды.\", ephemeral=True)\n",
            "            return\n",
            "        \n",
            "        # Проверка, что у участника уже нет этой роли\n",
            "        if role in member.roles:\n",
            "            await interaction.response.send_message(\"Этот участник уже имеет эту роль.\", ephemeral=True)\n",
            "            return\n",
            "        \n",
            "        # Добавляем роль участнику\n",
            "        await member.add_roles(role)\n",
            "\n",
            "        # Создаем embed для подтверждения\n",
            "        embed = disnake.Embed(\n",
            "            title=\"Роль успешно добавлена\",\n",
            "            description=f'Роль {role.mention} была успешно добавлена участнику {member.mention}.',\n",
            "            color=disnake.Color.from_rgb(255, 182, 193)  # Нежный розовый цвет\n",
            "        )\n",
            "        \n",
            "        # Устанавливаем аватарку участника справа сверху\n",
            "        embed.set_thumbnail(url=member.display_avatar.url)\n",
            "        \n",
            "        # Устанавливаем footer с именем и аватаркой администратора, который использовал команду\n",
            "        embed.set_footer(text=f\"Администратор: {interaction.user.display_name}\", icon_url=interaction.user.display_avatar.url)\n",
            "\n",
            "        # Отправляем embed\n",
            "        await interaction.response.send_message(embed=embed)\n",
            "\n",
            "        # Логируем действие\n",
            "        action = {\n",
            "            \"command\": \"/user_role_add\",  # Строка с командой\n",
            "            \"role_name\": role.name,       # Имя роли\n",
            "        }\n",
            "        await self.log_action(interaction, member, role, action)  # Логируем добавление роли\n",
            "\n",
            "    @commands.slash_command(name=\"user_role_remove\", description=\"Удалить роль у выбранного участника\")\n",
            "    async def user_role_remove(\n",
            "        self, \n",
            "        interaction: disnake.ApplicationCommandInteraction, \n",
            "        member: disnake.Member, \n",
            "        role: disnake.Role\n",
            "    ):\n",
            "        \"\"\"Удаляет роль у участника и отправляет embed с подтверждением\"\"\"\n",
            "        \n",
            "        # Проверка, что у пользователя есть нужная роль\n",
            "        admin_roles = config.get('ADMIN', [])\n",
            "        if not any(r.id in admin_roles for r in interaction.author.roles):\n",
            "            await interaction.response.send_message(\"У вас нет прав для использования этой команды.\", ephemeral=True)\n",
            "            return\n",
            "        \n",
            "        # Проверка, что у участника есть эта роль\n",
            "        if role not in member.roles:\n",
            "            await interaction.response.send_message(\"У участника нет этой роли.\", ephemeral=True)\n",
            "            return\n",
            "        \n",
            "        # Удаляем роль у участника\n",
            "        await member.remove_roles(role)\n",
            "\n",
            "        # Создаем embed для подтверждения\n",
            "        embed = disnake.Embed(\n",
            "            title=\"Роль успешно удалена\",\n",
            "            description=f'Роль {role.mention} была успешно удалена у участника {member.mention}.',\n",
            "            color=disnake.Color.from_rgb(255, 182, 193)  # Нежный розовый цвет\n",
            "        )\n",
            "        \n",
            "        # Устанавливаем аватарку участника справа сверху\n",
            "        embed.set_thumbnail(url=member.display_avatar.url)\n",
            "        \n",
            "        # Устанавливаем footer с именем и аватаркой администратора, который использовал команду\n",
            "        embed.set_footer(text=f\"Администратор: {interaction.user.display_name}\", icon_url=interaction.user.display_avatar.url)\n",
            "\n",
            "        # Отправляем embed\n",
            "        await interaction.response.send_message(embed=embed)\n",
            "\n",
            "        # Логируем действие\n",
            "        action = {\n",
            "            \"command\": \"/user_role_remove\",  # Строка с командой\n",
            "            \"role_name\": role.name,          # Имя роли\n",
            "        }\n",
            "        await self.log_action(interaction, member, role, action)  # Логируем удаление роли\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(RoleManagement(bot))\n"
        ]
    },
    "admin_func/role_all.py": {
        "hash": "3dd29e908d96ca0911be8eb98f29b4f6",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from disnake.ui import Button, View\n",
            "import json  # Для работы с JSON файлом\n",
            "import asyncio  # Для асинхронной работы с длительными операциями\n",
            "\n",
            "class ServerRoleManagement(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        self.cancelled = False  # Флаг для отмены операции\n",
            "        with open('conf/config.json', 'r', encoding='utf-8') as f:\n",
            "            self.config = json.load(f)\n",
            "\n",
            "    async def cancel_operation(self, interaction, embed, action):\n",
            "        \"\"\"Отменяет операцию и отправляет embed с сообщением об отмене.\"\"\"\n",
            "        self.cancelled = True  # Устанавливаем флаг отмены\n",
            "        embed.title = f\"Операция {action} отменена!\"\n",
            "        embed.description = f\"Процесс {action} был отменен администраторами в процессе выполнения.\"\n",
            "        \n",
            "        # Отправляем сообщение об отмене\n",
            "        try:\n",
            "            if not interaction.response.is_done():\n",
            "                await interaction.response.send_message(embed=embed, ephemeral=False)\n",
            "            else:\n",
            "                await interaction.followup.send(embed=embed, ephemeral=False)\n",
            "        except Exception as e:\n",
            "            print(f\"Ошибка при отправке сообщения об отмене: {e}\")\n",
            "            await interaction.followup.send(\"Не удалось отправить сообщение.\", ephemeral=True)\n",
            "\n",
            "    async def log_action(self, interaction, role, action):\n",
            "        \"\"\"Создает embed для логирования и отправляет его в лог-канал.\"\"\"\n",
            "        log_channel_id = self.config[\"ADMIN_LOG_CHANNEL\"]\n",
            "        log_channel = self.bot.get_channel(log_channel_id)\n",
            "\n",
            "        if log_channel:\n",
            "            try:\n",
            "                log_embed = disnake.Embed(\n",
            "                    title=\"Log\",\n",
            "                    color=disnake.Color.blue()\n",
            "                )\n",
            "                log_embed.add_field(name=\"Команда:\", value=action, inline=False)\n",
            "                log_embed.add_field(name=\"Роль:\", value=role.mention, inline=False)\n",
            "                log_embed.add_field(name=\"Канал:\", value=interaction.channel.mention, inline=False)\n",
            "                log_embed.set_thumbnail(url=interaction.user.display_avatar.url)\n",
            "                log_embed.set_footer(\n",
            "                    text=f\"Администратор: {interaction.user.display_name}\", \n",
            "                    icon_url=interaction.user.display_avatar.url\n",
            "                )\n",
            "                log_embed.timestamp = interaction.created_at\n",
            "\n",
            "                await log_channel.send(embed=log_embed)\n",
            "                print(f\"Лог отправлен: {action} для роли {role.name}\")\n",
            "            except Exception as e:\n",
            "                print(f\"Ошибка при отправке лога: {e}\")\n",
            "                # Если ошибка, попробуем отправить сообщение в общий канал\n",
            "                await interaction.followup.send(\"Не удалось отправить лог в канал.\", ephemeral=True)\n",
            "        else:\n",
            "            print(f\"Канал для логирования с ID {log_channel_id} не найден.\")\n",
            "            # Если канал не найден, отправим сообщение в общий канал\n",
            "            await interaction.followup.send(\"Канал для логирования не найден.\", ephemeral=True)\n",
            "\n",
            "    @commands.slash_command(name=\"server_role_add_all\", description=\"Выдать роль всем участникам сервера\")\n",
            "    async def server_role_add_all(self, interaction: disnake.ApplicationCommandInteraction, role: disnake.Role):\n",
            "        \"\"\"Выдает указанную роль всем участникам на сервере\"\"\"\n",
            "        \n",
            "        if not any(r.id in self.config[\"ADMIN\"] for r in interaction.author.roles):\n",
            "            await interaction.response.send_message(\"У вас нет прав для использования этой команды.\", ephemeral=True)\n",
            "            return\n",
            "        \n",
            "        members = [member for member in interaction.guild.members if role not in member.roles]\n",
            "        count = len(members)\n",
            "\n",
            "        cancel_button = Button(label=\"Отменить\", style=disnake.ButtonStyle.red)\n",
            "        embed = disnake.Embed(\n",
            "            title=\"Роль выдается всем участникам!\",\n",
            "            description=f\"Роль {role.mention} будет выдана {count} пользователям сервера. Процесс начнется немедленно.\",\n",
            "            color=disnake.Color.from_rgb(255, 182, 193)\n",
            "        )\n",
            "        embed.set_thumbnail(url=self.bot.user.avatar.url)\n",
            "        embed.set_footer(text=f\"Администратор: {interaction.user.display_name}\", icon_url=interaction.user.display_avatar.url)\n",
            "\n",
            "        view = View(timeout=None)\n",
            "        view.add_item(cancel_button)\n",
            "\n",
            "        try:\n",
            "            await interaction.response.send_message(embed=embed, view=view)\n",
            "        except Exception as e:\n",
            "            print(f\"Ошибка при отправке сообщения: {e}\")\n",
            "            await interaction.followup.send(\"Не удалось отправить сообщение.\", ephemeral=True)\n",
            "            return\n",
            "\n",
            "        async def cancel_button_callback(interaction):\n",
            "            await self.cancel_operation(interaction, embed, \"выдачи ролей\")\n",
            "\n",
            "        cancel_button.callback = cancel_button_callback\n",
            "\n",
            "        async def add_roles_to_all():\n",
            "            for member in members:\n",
            "                if self.cancelled:\n",
            "                    break\n",
            "                await member.add_roles(role)\n",
            "                await asyncio.sleep(1)\n",
            "\n",
            "            if not self.cancelled:\n",
            "                success_embed = disnake.Embed(\n",
            "                    title=\"Роль успешно выдана всем участникам!\",\n",
            "                    description=f\"Роль {role.mention} была выдана {count} пользователям сервера.\",\n",
            "                    color=disnake.Color.green()\n",
            "                )\n",
            "                success_embed.set_thumbnail(url=self.bot.user.avatar.url)\n",
            "                success_embed.set_footer(text=f\"Администратор: {interaction.user.display_name}\", icon_url=interaction.user.display_avatar.url)\n",
            "\n",
            "                await interaction.followup.send(embed=success_embed)\n",
            "                await self.log_action(interaction, role, \"/server_role_add_all\")\n",
            "\n",
            "        self.cancelled = False\n",
            "        await add_roles_to_all()\n",
            "\n",
            "    @commands.slash_command(name=\"server_role_remove_all\", description=\"Удалить роль у всех участников сервера\")\n",
            "    async def server_role_remove_all(self, interaction: disnake.ApplicationCommandInteraction, role: disnake.Role):\n",
            "        \"\"\"Удаляет указанную роль у всех участников на сервере\"\"\"\n",
            "        \n",
            "        if not any(r.id in self.config[\"ADMIN\"] for r in interaction.author.roles):\n",
            "            await interaction.response.send_message(\"У вас нет прав для использования этой команды.\", ephemeral=True)\n",
            "            return\n",
            "        \n",
            "        members = [member for member in interaction.guild.members if role in member.roles]\n",
            "        count = len(members)\n",
            "\n",
            "        cancel_button = Button(label=\"Отменить\", style=disnake.ButtonStyle.red)\n",
            "        embed = disnake.Embed(\n",
            "            title=\"Роль удаляется у всех участников!\",\n",
            "            description=f\"Роль {role.mention} будет удалена у {count} пользователей. Процесс начнется немедленно.\",\n",
            "            color=disnake.Color.from_rgb(255, 182, 193)\n",
            "        )\n",
            "        embed.set_thumbnail(url=self.bot.user.avatar.url)\n",
            "        embed.set_footer(text=f\"Администратор: {interaction.user.display_name}\", icon_url=interaction.user.display_avatar.url)\n",
            "\n",
            "        view = View(timeout=None)\n",
            "        view.add_item(cancel_button)\n",
            "\n",
            "        try:\n",
            "            await interaction.response.send_message(embed=embed, view=view)\n",
            "        except Exception as e:\n",
            "            print(f\"Ошибка при отправке сообщения: {e}\")\n",
            "            await interaction.followup.send(\"Не удалось отправить сообщение.\", ephemeral=True)\n",
            "            return\n",
            "\n",
            "        async def cancel_button_callback(interaction):\n",
            "            await self.cancel_operation(interaction, embed, \"удаления ролей\")\n",
            "\n",
            "        cancel_button.callback = cancel_button_callback\n",
            "\n",
            "        async def remove_roles_from_all():\n",
            "            for member in members:\n",
            "                if self.cancelled:\n",
            "                    break\n",
            "                await member.remove_roles(role)\n",
            "                await asyncio.sleep(1)\n",
            "\n",
            "            if not self.cancelled:\n",
            "                success_embed = disnake.Embed(\n",
            "                    title=\"Роль успешно удалена у всех участников!\",\n",
            "                    description=f\"Роль {role.mention} была удалена у {count} пользователей.\",\n",
            "                    color=disnake.Color.green()\n",
            "                )\n",
            "                success_embed.set_thumbnail(url=self.bot.user.avatar.url)\n",
            "                success_embed.set_footer(text=f\"Администратор: {interaction.user.display_name}\", icon_url=interaction.user.display_avatar.url)\n",
            "\n",
            "                await interaction.followup.send(embed=success_embed)\n",
            "                await self.log_action(interaction, role, \"/server_role_remove_all\")\n",
            "\n",
            "        self.cancelled = False\n",
            "        await remove_roles_from_all()\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_ready(self):\n",
            "        self.cancelled = False\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(ServerRoleManagement(bot))\n"
        ]
    },
    "admin_func/role_settings.py": {
        "hash": "822ca2f28a846610010b24501fcf00bb",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from disnake import Color\n",
            "import json # Для работы с JSON файлом\n",
            "\n",
            "\n",
            "class ServerRoleSettings(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        with open('conf/config.json', 'r', encoding='utf-8') as f:\n",
            "            self.config = json.load(f)\n",
            "\n",
            "    async def log_action(self, interaction, role, action):\n",
            "        \"\"\"Создает embed для логирования и отправляет его в лог-канал.\"\"\"\n",
            "        log_channel_id = self.config[\"ADMIN_LOG_CHANNEL\"]\n",
            "        log_channel = self.bot.get_channel(log_channel_id)\n",
            "\n",
            "        if log_channel:\n",
            "            try:\n",
            "                log_embed = disnake.Embed(\n",
            "                    title=\"Лог создания роли\",\n",
            "                    color=disnake.Color.blue()\n",
            "                )\n",
            "                log_embed.add_field(name=\"Команда:\", value=action[\"command\"], inline=False)\n",
            "                log_embed.add_field(name=\"Роль:\", value=f\"**{role.name}**\", inline=False)\n",
            "                log_embed.add_field(name=\"Цвет:\", value=action[\"color\"], inline=False)\n",
            "                log_embed.add_field(name=\"Позиция:\", value=action[\"position\"], inline=False)\n",
            "                log_embed.set_footer(\n",
            "                    text=f\"Администратор: {interaction.user.display_name}\",\n",
            "                    icon_url=interaction.user.display_avatar.url\n",
            "                )\n",
            "                log_embed.timestamp = interaction.created_at\n",
            "\n",
            "                await log_channel.send(embed=log_embed)\n",
            "                print(f\"Лог отправлен: {action['command']} для роли {role.name}\")\n",
            "            except Exception as e:\n",
            "                print(f\"Ошибка при отправке лога: {e}\")\n",
            "                await interaction.followup.send(\"Не удалось отправить лог в канал.\", ephemeral=True)\n",
            "        else:\n",
            "            print(f\"Канал для логирования с ID {log_channel_id} не найден.\")\n",
            "            await interaction.followup.send(\"Канал для логирования не найден.\", ephemeral=True)\n",
            "\n",
            "    @commands.slash_command()\n",
            "    async def server_role_create(\n",
            "        self, \n",
            "        ctx: disnake.ApplicationCommandInteraction, \n",
            "        name: str, \n",
            "        position: int, \n",
            "        color: str = None\n",
            "    ):\n",
            "        \"\"\"\n",
            "        Создать роль на сервере.\n",
            "        \"\"\"\n",
            "        # Проверка прав доступа\n",
            "        if not any(role.id in self.config[\"ADMIN\"] for role in ctx.author.roles):\n",
            "            await ctx.send(\n",
            "                embed=disnake.Embed(\n",
            "                    description=\"❌ У вас недостаточно прав для выполнения этой команды.\",\n",
            "                    color=disnake.Color.red()\n",
            "                ),\n",
            "                ephemeral=True\n",
            "            )\n",
            "            return\n",
            "\n",
            "        # Обработка цвета\n",
            "        try:\n",
            "            role_color = disnake.Color(int(color.lstrip(\"#\"), 16)) if color else disnake.Color.from_rgb(255, 182, 193)\n",
            "        except ValueError:\n",
            "            await ctx.send(\n",
            "                embed=disnake.Embed(\n",
            "                    description=\"❌ Неверный формат цвета. Используйте HEX-код, например: `#FF5733`.\",\n",
            "                    color=disnake.Color.red()\n",
            "                ),\n",
            "                ephemeral=True\n",
            "            )\n",
            "            return\n",
            "\n",
            "        # Создание роли\n",
            "        try:\n",
            "            guild = ctx.guild\n",
            "            new_role = await guild.create_role(name=name, color=role_color)\n",
            "\n",
            "            # Перемещение роли на нужную позицию\n",
            "            await new_role.edit(position=position)\n",
            "\n",
            "            # Ответ пользователю\n",
            "            embed = disnake.Embed(\n",
            "                title=\"Роль создана\",\n",
            "                description=f\"✅ Роль **{name}** успешно создана.\",\n",
            "                color=role_color\n",
            "            )\n",
            "            embed.add_field(name=\"Позиция\", value=f\"{position}\")\n",
            "            embed.add_field(name=\"Цвет\", value=color if color else \"Нежно-розовый\")\n",
            "\n",
            "            await ctx.send(embed=embed)\n",
            "\n",
            "            # Логируем создание роли\n",
            "            action = {\n",
            "                \"command\": \"/server_role_create\",\n",
            "                \"color\": color if color else \"Нежно-розовый\",\n",
            "                \"position\": position\n",
            "            }\n",
            "            await self.log_action(ctx, new_role, action)\n",
            "\n",
            "        except Exception as e:\n",
            "            await ctx.send(\n",
            "                embed=disnake.Embed(\n",
            "                    description=f\"❌ Произошла ошибка при создании роли: {str(e)}\",\n",
            "                    color=disnake.Color.red()\n",
            "                ),\n",
            "                ephemeral=True\n",
            "            )\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(ServerRoleSettings(bot))\n"
        ]
    },
    "admin_func/slowmode.py": {
        "hash": "c7666c4e746bb1c4fe43caa2484060d9",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "import json # Для работы с JSON файлом\n",
            "\n",
            "class Slowmode(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        with open('conf/config.json', 'r', encoding='utf-8') as f:\n",
            "            self.config = json.load(f)\n",
            "\n",
            "    @commands.slash_command(name=\"server_slowmode\", description=\"Установить задержку между сообщениями в канале\")\n",
            "    async def slowmode(\n",
            "        self, \n",
            "        interaction: disnake.ApplicationCommandInteraction, \n",
            "        channel: disnake.TextChannel, \n",
            "        time: int\n",
            "    ):\n",
            "        \"\"\"Устанавливает задержку (slowmode) для выбранного канала\"\"\"\n",
            "        \n",
            "        # Проверка, что у пользователя есть нужная роль\n",
            "        if not any(role.id in self.config[\"ADMIN\"] for role in interaction.author.roles):\n",
            "            await interaction.response.send_message(\"У вас нет прав для использования этой команды.\", ephemeral=True)\n",
            "            return\n",
            "        \n",
            "        # Создание embed для основного ответа\n",
            "        if time == 0:\n",
            "            await channel.edit(slowmode_delay=0)\n",
            "            embed = disnake.Embed(\n",
            "                title=\"Режим замедления отключен!\",\n",
            "                description=f\"В канале {channel.mention} была отключена задержка между сообщениями.\",\n",
            "                color=disnake.Color.from_rgb(255, 182, 193)  # Нежный розовый цвет\n",
            "            )\n",
            "            action_text = \"Режим замедления отключен\"\n",
            "        else:\n",
            "            await channel.edit(slowmode_delay=time)\n",
            "            embed = disnake.Embed(\n",
            "                title=\"Режим замедления установлен!\",\n",
            "                description=f\"В канале {channel.mention} была установлена задержка между сообщениями: {time} секунд.\",\n",
            "                color=disnake.Color.from_rgb(255, 182, 193)  # Нежный розовый цвет\n",
            "            )\n",
            "            action_text = f\"Режим замедления активирован на {time} секунд\"\n",
            "        \n",
            "        # Устанавливаем аватарку бота справа сверху\n",
            "        embed.set_thumbnail(url=self.bot.user.avatar.url)\n",
            "        \n",
            "        # Устанавливаем footer с именем и аватаркой администратора, который использовал команду\n",
            "        embed.set_footer(text=f\"Администратор: {interaction.user.display_name}\", icon_url=interaction.user.display_avatar.url)\n",
            "\n",
            "        # Отправляем embed-ответ\n",
            "        await interaction.response.send_message(embed=embed)\n",
            "\n",
            "        # Логирование действия в канал ADMIN_LOG_CHANNEL\n",
            "        log_channel_id = self.config[\"ADMIN_LOG_CHANNEL\"]\n",
            "        log_channel = self.bot.get_channel(log_channel_id)\n",
            "        if log_channel:\n",
            "            log_embed = disnake.Embed(\n",
            "                title=\"Log\",\n",
            "                color=disnake.Color.blue()\n",
            "            )\n",
            "            # Поле с информацией о команде\n",
            "            log_embed.add_field(name=\"Команда:\", value=\"/server_slowmode\", inline=False)\n",
            "            log_embed.add_field(name=\"Канал:\", value=channel.mention, inline=False)\n",
            "            log_embed.add_field(name=\"Задержка:\", value=f\"{time} секунд\" if time > 0 else \"Отключена\", inline=False)\n",
            "\n",
            "            # Аватарка администратора справа сверху\n",
            "            log_embed.set_thumbnail(url=interaction.user.display_avatar.url)\n",
            "\n",
            "            # Footer с именем администратора и его аватаркой\n",
            "            log_embed.set_footer(\n",
            "                text=f\"Администратор: {interaction.user.display_name}\", \n",
            "                icon_url=interaction.user.display_avatar.url\n",
            "            )\n",
            "            log_embed.timestamp = interaction.created_at\n",
            "            \n",
            "            await log_channel.send(embed=log_embed)\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(Slowmode(bot))\n"
        ]
    },
    "admin_func/ticket_send.py": {
        "hash": "ae52a0456afc4d66c0b920b93284bfc4",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from disnake.ui import Button, View\n",
            "import json\n",
            "\n",
            "# Загрузка конфигурации из JSON файла\n",
            "with open('conf/config.json', 'r', encoding='utf-8') as f:\n",
            "    config = json.load(f)\n",
            "\n",
            "\n",
            "class SupportTicket(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "\n",
            "    @commands.slash_command(name=\"dev_ticket_send\", description=\"Отправить сообщение для открытия тикета.\")\n",
            "    async def dev_ticket_send(\n",
            "        self,\n",
            "        inter: disnake.ApplicationCommandInteraction,\n",
            "        channel: disnake.TextChannel\n",
            "    ):\n",
            "        \"\"\"Отправляет сообщение с кнопкой для открытия тикета.\"\"\"\n",
            "        # Проверка на права\n",
            "        user_roles = {role.id for role in inter.user.roles}\n",
            "        admin_roles = set(config[\"ADMIN\"])\n",
            "\n",
            "        if not user_roles & admin_roles:\n",
            "            await inter.response.send_message(\n",
            "                \"У вас недостаточно прав для использования этой команды.\",\n",
            "                ephemeral=True\n",
            "            )\n",
            "            return\n",
            "\n",
            "        # Создание Embed для сообщения\n",
            "        embed = disnake.Embed(\n",
            "            title=\"Возникли вопросы?\",\n",
            "            description=\"Вы можете открыть обращение, напрямую ожидая помощи от администрации\",\n",
            "            color=disnake.Color.green()\n",
            "        )\n",
            "        embed.set_image(url=\"https://i.pinimg.com/originals/fd/db/60/fddb602396802a3de27e2dc30fd75896.gif\")\n",
            "        embed.set_footer(text=\"Не грустите, мы вам поможем :D\")\n",
            "\n",
            "        # Создание кнопки\n",
            "        view = View(timeout=None)  # View без тайм-аута, чтобы кнопка оставалась активной после перезагрузки\n",
            "        button = Button(label=\"Открыть обращение\", style=disnake.ButtonStyle.blurple, custom_id=\"open_support_ticket\")\n",
            "        view.add_item(button)\n",
            "\n",
            "        # Отправка сообщения\n",
            "        await channel.send(embed=embed, view=view)\n",
            "        await inter.response.send_message(\"Сообщение с тикетом отправлено!\", ephemeral=True)\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_button_click(self, interaction: disnake.MessageInteraction):\n",
            "        \"\"\"Обработка нажатия кнопки для открытия тикета.\"\"\"\n",
            "        if interaction.data[\"custom_id\"] != \"open_support_ticket\":\n",
            "            return\n",
            "\n",
            "        # Проверяем, существует ли уже тикет для этого пользователя\n",
            "        category_id = 878553432053665852\n",
            "        category = interaction.guild.get_channel(category_id)\n",
            "        if not category:\n",
            "            await interaction.response.send_message(\n",
            "                \"Категория для тикетов не найдена. Обратитесь к администратору.\",\n",
            "                ephemeral=True\n",
            "            )\n",
            "            return\n",
            "\n",
            "        existing_channel = disnake.utils.get(\n",
            "            category.channels, name=f\"ticket-{interaction.user.name.lower()}\"\n",
            "        )\n",
            "        if existing_channel:\n",
            "            await interaction.response.send_message(\n",
            "                f\"У вас уже есть открытый тикет: {existing_channel.mention}\",\n",
            "                ephemeral=True\n",
            "            )\n",
            "            return\n",
            "\n",
            "        # Создание нового канала\n",
            "        overwrites = {\n",
            "            interaction.guild.default_role: disnake.PermissionOverwrite(view_channel=False),\n",
            "            interaction.user: disnake.PermissionOverwrite(view_channel=True, send_messages=True, read_message_history=True),\n",
            "            interaction.guild.get_role(1294045970975428628): disnake.PermissionOverwrite(view_channel=True),\n",
            "            interaction.guild.get_role(784160890761117767): disnake.PermissionOverwrite(view_channel=True),\n",
            "            interaction.guild.get_role(1025668964447158322): disnake.PermissionOverwrite(view_channel=True),\n",
            "        }\n",
            "\n",
            "        ticket_channel = await category.create_text_channel(\n",
            "            name=f\"ticket-{interaction.user.name.lower()}\",\n",
            "            overwrites=overwrites\n",
            "        )\n",
            "\n",
            "        # Отправка Embed в новый канал\n",
            "        embed = disnake.Embed(\n",
            "            title=f\"{interaction.user.display_name} открывает обращение\",\n",
            "            description=\"Не переживайте, совсем скоро вам помогут 🌅\",\n",
            "            color=disnake.Color.blue()\n",
            "        )\n",
            "        embed.set_image(url=\"https://i.pinimg.com/originals/dc/f3/7a/dcf37a91bd27c05db5cfa4906176513d.gif\")\n",
            "\n",
            "        await ticket_channel.send(\"@everyone\", embed=embed)\n",
            "\n",
            "        # Ответ пользователю\n",
            "        await interaction.response.send_message(\n",
            "            f\"Тикет создан: {ticket_channel.mention}\", ephemeral=True\n",
            "        )\n",
            "\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(SupportTicket(bot))\n"
        ]
    },
    "dev_func/bot_reload.py": {
        "hash": "73f17ea70c3cf64897e4519dbc2717d7",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "import os\n",
            "import sys\n",
            "import asyncio\n",
            "import logging\n",
            "import json\n",
            "from disnake import Embed\n",
            "from datetime import datetime\n",
            "\n",
            "# Загрузка конфигурации\n",
            "with open('conf/config.json', 'r', encoding='utf-8') as f:\n",
            "    config = json.load(f)\n",
            "\n",
            "# Настройка логирования\n",
            "logging.basicConfig(level=logging.INFO)\n",
            "\n",
            "class DeveloperCommands(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "\n",
            "    @commands.slash_command(name=\"dev_bot_reload\", description=\"Перезагрузить бота\")\n",
            "    async def dev_bot_reload(\n",
            "        self, \n",
            "        interaction: disnake.ApplicationCommandInteraction\n",
            "    ):\n",
            "        \"\"\"Перезагружает бота и отправляет embed с подтверждением\"\"\"\n",
            "        \n",
            "        # Проверка прав: пользователь должен быть владельцем бота\n",
            "        if interaction.author.id != config[\"BOT_OWNER\"]:\n",
            "            await interaction.response.send_message(\n",
            "                \"У вас нет прав для использования этой команды.\",\n",
            "                ephemeral=True\n",
            "            )\n",
            "            return\n",
            "        \n",
            "        # Генерация embed перед перезагрузкой\n",
            "        embed = Embed(\n",
            "            title=\"🚀 Перезагрузка бота\",\n",
            "            description=(  # Описание перезагрузки\n",
            "                \"Бот будет перезагружен. Все настройки и данные будут восстановлены.\\n\\n\"\n",
            "                \"✅ **Разрешения**: Бот перезагружен с полными правами на выполнение команд.\\n\"\n",
            "                \"⏱ **Время перезагрузки**: Процесс завершится через несколько секунд.\\n\\n\"\n",
            "                \"Это действие было инициировано разработчиком.\"\n",
            "            ),\n",
            "            color=disnake.Color.blue()\n",
            "        )\n",
            "        \n",
            "        embed.add_field(\n",
            "            name=\"🔧 Дополнительная информация\", \n",
            "            value=(  # Дополнительные подробности о перезагрузке\n",
            "                \"Перезагрузка бота может занять несколько секунд. После перезагрузки \"\n",
            "                \"бот будет готов к выполнению команд. Все временные данные и настройки \"\n",
            "                \"будут восстановлены без потерь.\"\n",
            "            ),\n",
            "            inline=False\n",
            "        )\n",
            "        \n",
            "        # Устанавливаем аватарку бота справа сверху (не в поле автора)\n",
            "        embed.set_thumbnail(url=self.bot.user.display_avatar.url)\n",
            "        \n",
            "        # Добавляем footer с именем и аватаром администратора\n",
            "        embed.set_footer(\n",
            "            text=f\"Перезагружено разработчиком: {interaction.user.display_name}\",\n",
            "            icon_url=interaction.user.display_avatar.url\n",
            "        )\n",
            "\n",
            "        # Отправка embed перед перезагрузкой\n",
            "        await interaction.response.send_message(embed=embed)\n",
            "\n",
            "        # Логируем информацию о перезагрузке в консоль\n",
            "        logging.info(f\"Bot reload initiated by {interaction.user.display_name} ({interaction.user.id}) at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}.\")\n",
            "\n",
            "        # Ожидание перед перезагрузкой, чтобы сообщение успело отправиться\n",
            "        await asyncio.sleep(2)\n",
            "        \n",
            "        # Перезагружаем бота\n",
            "        os.execv(sys.executable, ['python'] + sys.argv)\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_ready(self):\n",
            "        \"\"\"Слушатель события, когда бот готов.\"\"\"\n",
            "        \n",
            "        # Генерация embed после успешной перезагрузки\n",
            "        embed = Embed(\n",
            "            title=\"🎉 Бот успешно перезагружен\",\n",
            "            description=\"Перезагрузка завершена! Все настройки и коги были загружены.\",\n",
            "            color=disnake.Color.green()\n",
            "        )\n",
            "\n",
            "        embed.add_field(\n",
            "            name=\"🔧 Статус перезагрузки\",\n",
            "            value=\"Все коги были успешно загружены и бот готов к работе.\",\n",
            "            inline=False\n",
            "        )\n",
            "        \n",
            "        # Получаем список загруженных когов\n",
            "        loaded_cogs = \", \".join(self.bot.cogs.keys())  # Получаем все ключи из self.bot.cogs\n",
            "        embed.add_field(\n",
            "            name=\"📚 Загруженные коги:\",\n",
            "            value=loaded_cogs,\n",
            "            inline=False\n",
            "        )\n",
            "\n",
            "        embed.set_thumbnail(url=self.bot.user.display_avatar.url)\n",
            "        \n",
            "        # Отправка embed в канал, где администратор может увидеть успешную перезагрузку\n",
            "        channel = self.bot.get_channel(config[\"ADMIN_LOG_CHANNEL\"])\n",
            "        if channel:\n",
            "            await channel.send(embed=embed)\n",
            "\n",
            "        # Логируем успешную перезагрузку\n",
            "        logging.info(f\"Bot successfully reloaded at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}. Loaded cogs: {', '.join(self.bot.cogs.keys())}.\")\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(DeveloperCommands(bot))\n"
        ]
    },
    "dev_func/cogs.py": {
        "hash": "0397ba0e84c7a7c68ddfcbe33758f638",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from pathlib import Path\n",
            "import json\n",
            "\n",
            "# Загрузка конфигурации\n",
            "with open('conf/config.json', 'r', encoding='utf-8') as f:\n",
            "    config = json.load(f)\n",
            "#1\n",
            "\n",
            "class DevCogManager(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "\n",
            "    async def _handle_cog(self, inter: disnake.ApplicationCommandInteraction, action: str, cog: str):\n",
            "        # Проверка ролей пользователя\n",
            "        if not any(role.id in config[\"ADMIN\"] for role in inter.author.roles):\n",
            "            await inter.response.send_message(\n",
            "                embed=disnake.Embed(\n",
            "                    title=\"🚫 Недостаточно прав\",\n",
            "                    description=\"У вас недостаточно прав для выполнения этой команды. \"\n",
            "                                \"Команда доступна только администраторам.\",\n",
            "                    color=disnake.Color.red(),\n",
            "                ),\n",
            "                ephemeral=True,\n",
            "            )\n",
            "            return\n",
            "\n",
            "        # Директории для поиска когов\n",
            "        directories = [\n",
            "            \"admin_func\",\n",
            "            \"dev_func\",\n",
            "            \"event\",\n",
            "            \"news\",\n",
            "            \"server_func\",\n",
            "            \"user_func\",\n",
            "        ]\n",
            "\n",
            "        cog_path = None\n",
            "        # Поиск когов по директориям\n",
            "        for directory in directories:\n",
            "            potential_path = f\"{directory}.{cog}\"\n",
            "            if action != \"load\" and potential_path in self.bot.extensions:\n",
            "                cog_path = potential_path\n",
            "                break\n",
            "            elif action == \"load\" and Path(f\"{directory}/{cog}.py\").exists():\n",
            "                cog_path = potential_path\n",
            "                break\n",
            "\n",
            "        # Если ког не найден\n",
            "        if cog_path is None:\n",
            "            await inter.response.send_message(\n",
            "                embed=disnake.Embed(\n",
            "                    title=\"❌ Ког не найден\",\n",
            "                    description=f\"Ког **{cog}** не найден в указанных директориях:\\n\\n\"\n",
            "                                + \"\\n\".join(f\"`{d}`\" for d in directories),\n",
            "                    color=disnake.Color.red(),\n",
            "                )\n",
            "            )\n",
            "            return\n",
            "\n",
            "        # Выполнение действия (загрузка, выгрузка, перезагрузка)\n",
            "        try:\n",
            "            if action == \"load\":\n",
            "                self.bot.load_extension(cog_path)\n",
            "                result = f\"Ког **`{cog_path}`** успешно загружен.\"\n",
            "                color = disnake.Color.green()\n",
            "                icon = \"✅\"\n",
            "            elif action == \"unload\":\n",
            "                self.bot.unload_extension(cog_path)\n",
            "                result = f\"Ког **`{cog_path}`** успешно выгружен.\"\n",
            "                color = disnake.Color.orange()\n",
            "                icon = \"🟧\"\n",
            "            elif action == \"reload\":\n",
            "                self.bot.reload_extension(cog_path)\n",
            "                result = f\"Ког **`{cog_path}`** успешно перезагружен.\"\n",
            "                color = disnake.Color.blurple()\n",
            "                icon = \"🔄\"\n",
            "        except Exception as e:\n",
            "            result = f\"Произошла ошибка при выполнении операции с когом **`{cog_path}`**:\\n```{e}```\"\n",
            "            color = disnake.Color.red()\n",
            "            icon = \"❌\"\n",
            "\n",
            "        # Отправка результата\n",
            "        embed = disnake.Embed(\n",
            "            title=f\"{icon} Результат команды: {action.capitalize()} Cog\",\n",
            "            description=result,\n",
            "            color=color,\n",
            "        )\n",
            "        embed.add_field(name=\"Действие\", value=f\"`{action.capitalize()}`\", inline=True)\n",
            "        embed.add_field(name=\"Название кoга\", value=f\"`{cog}`\", inline=True)\n",
            "        if action == \"load\":\n",
            "            embed.add_field(name=\"Статус\", value=\"Ког успешно загружен в систему.\", inline=False)\n",
            "        elif action == \"unload\":\n",
            "            embed.add_field(name=\"Статус\", value=\"Ког был успешно выгружен из системы.\", inline=False)\n",
            "        elif action == \"reload\":\n",
            "            embed.add_field(name=\"Статус\", value=\"Ког был успешно перезагружен.\", inline=False)\n",
            "        else:\n",
            "            embed.add_field(name=\"Статус\", value=\"Операция завершена.\", inline=False)\n",
            "\n",
            "        embed.set_footer(text=f\"Выполнено: {inter.author}\", icon_url=inter.author.display_avatar.url)\n",
            "\n",
            "        await inter.response.send_message(embed=embed)\n",
            "\n",
            "    @commands.slash_command()\n",
            "    async def dev_cog(\n",
            "        self,\n",
            "        inter: disnake.ApplicationCommandInteraction,\n",
            "        action: str = commands.Param(choices=[\"load\", \"unload\", \"reload\"]),\n",
            "        cog: str = commands.Param(description=\"Название ког файла (без .py)\"),\n",
            "    ):\n",
            "        \"\"\"\n",
            "        Управление когами (загрузка, выгрузка, перезагрузка).\n",
            "        Только для администраторов.\n",
            "        \"\"\"\n",
            "        await self._handle_cog(inter, action, cog)\n",
            "\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(DevCogManager(bot))\n"
        ]
    },
    "dev_func/cogs_status.py": {
        "hash": "e92646c2d2ea0ee7702ba43a92548694",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from pathlib import Path\n",
            "import json\n",
            "\n",
            "# Загрузка конфигурации\n",
            "with open('conf/config.json', 'r', encoding='utf-8') as f:\n",
            "    config = json.load(f)\n",
            "\n",
            "class DevCogShow(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "\n",
            "    @commands.slash_command()\n",
            "    async def dev_cog_show(self, inter: disnake.ApplicationCommandInteraction):\n",
            "        \"\"\"\n",
            "        Показывает список всех когов и их статусы (загружен/не загружен).\n",
            "        Только для администраторов.\n",
            "        \"\"\"\n",
            "        # Проверка ролей пользователя\n",
            "        if not any(role.id in config[\"ADMIN\"] for role in inter.author.roles):\n",
            "            await inter.response.send_message(\n",
            "                embed=disnake.Embed(\n",
            "                    title=\"🚫 Недостаточно прав\",\n",
            "                    description=\"У вас недостаточно прав для выполнения этой команды. \"\n",
            "                                \"Команда доступна только администраторам.\",\n",
            "                    color=disnake.Color.red(),\n",
            "                ),\n",
            "                ephemeral=True,\n",
            "            )\n",
            "            return\n",
            "\n",
            "        # Директории для когов\n",
            "        directories = [\n",
            "            \"admin_func\",\n",
            "            \"dev_func\",\n",
            "            \"event\",\n",
            "            \"news\",\n",
            "            \"server_func\",\n",
            "            \"user_func\",\n",
            "        ]\n",
            "\n",
            "        embed = disnake.Embed(\n",
            "            title=\"📜 Список когов\",\n",
            "            description=\"Здесь перечислены все коги в системе, отсортированные по директориям.\\n\\n\"\n",
            "                        \"✅ — Загружен | ❌ — Не загружен\",\n",
            "            color=disnake.Color.blurple(),\n",
            "        )\n",
            "\n",
            "        # Обработка каждой директории\n",
            "        for directory in directories:\n",
            "            cog_statuses = []\n",
            "            # Получение списка файлов в директории\n",
            "            dir_path = Path(directory)\n",
            "            if not dir_path.exists():\n",
            "                continue\n",
            "\n",
            "            for file in dir_path.iterdir():\n",
            "                if file.suffix == \".py\" and not file.name.startswith(\"_\"):\n",
            "                    cog_name = file.stem\n",
            "                    full_cog_name = f\"{directory}.{cog_name}\"\n",
            "                    status = \"✅ Load\" if full_cog_name in self.bot.extensions else \"❌ Unload\"\n",
            "                    cog_statuses.append(f\"**`{cog_name}`** — {status}\")\n",
            "\n",
            "            # Добавляем информацию в Embed\n",
            "            if cog_statuses:\n",
            "                embed.add_field(\n",
            "                    name=f\"📂 {directory}\",\n",
            "                    value=\"\\n\".join(cog_statuses),\n",
            "                    inline=False\n",
            "                )\n",
            "\n",
            "        embed.set_footer(\n",
            "            text=f\"Запрошено: {inter.author}\",\n",
            "            icon_url=inter.author.display_avatar.url\n",
            "        )\n",
            "\n",
            "        await inter.response.send_message(embed=embed)\n",
            "\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(DevCogShow(bot))\n"
        ]
    },
    "event/geyser_sky.py": {
        "hash": "9168f3982954254e0ad3bc6fd5d09738",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands, tasks\n",
            "from datetime import datetime, time, timedelta\n",
            "import logging\n",
            "import json\n",
            "import os\n",
            "\n",
            "# Настройка логирования\n",
            "logging.basicConfig(level=logging.INFO)\n",
            "\n",
            "class GeyserEvent(commands.Cog):\n",
            "    def __init__(self, bot: commands.Bot):\n",
            "        self.bot = bot\n",
            "        # Загружаем ID канала и роли из JSON файла\n",
            "        self.config = self.load_config()\n",
            "        self.channel_id = self.config[\"channel_id\"]\n",
            "        self.role_id = self.config[\"role_id\"]\n",
            "        self.image_url = \"https://i.pinimg.com/736x/37/c1/c3/37c1c3421ddb57facb9a6486a82c2666.jpg\"  # Ссылка на изображение\n",
            "        self.event_schedule = self.get_event_schedule()  # Получение расписания\n",
            "        self.last_event_time = None  # Отслеживание последнего времени события\n",
            "\n",
            "        self.check_event.start()  # Запуск проверки событий\n",
            "\n",
            "    def load_config(self):\n",
            "        \"\"\"Загружает конфигурацию из JSON файла.\"\"\"\n",
            "        config_path = os.path.join(\"data\", \"event_sky.json\")\n",
            "        try:\n",
            "            with open(config_path, 'r', encoding='utf-8') as f:\n",
            "                return json.load(f)\n",
            "        except FileNotFoundError:\n",
            "            logging.error(f\"Файл конфигурации {config_path} не найден\")\n",
            "            return {\"channel_id\": 0, \"role_id\": 0}\n",
            "        except json.JSONDecodeError:\n",
            "            logging.error(f\"Ошибка при чтении файла конфигурации {config_path}\")\n",
            "            return {\"channel_id\": 0, \"role_id\": 0}\n",
            "\n",
            "    def get_event_schedule(self):\n",
            "        \"\"\"Расписание событий (московское время).\"\"\"\n",
            "        summer_time = [\n",
            "            time(10, 0), time(12, 0), time(14, 0), time(16, 0), time(18, 0),\n",
            "            time(20, 0), time(22, 0), time(0, 0), time(2, 0), time(4, 0),\n",
            "            time(6, 0), time(8, 0)\n",
            "        ]\n",
            "        winter_time = [\n",
            "            time(11, 0), time(13, 0), time(15, 0), time(17, 0), time(19, 0),\n",
            "            time(21, 0), time(23, 0), time(1, 0), time(3, 0), time(5, 0),\n",
            "            time(7, 0), time(9, 0)\n",
            "        ]\n",
            "\n",
            "        # Определяем, какое сейчас время года\n",
            "        now = datetime.now()\n",
            "        if (3, 15) <= (now.month, now.day) <= (11, 15):  # Летнее время\n",
            "            return summer_time\n",
            "        else:  # Зимнее время\n",
            "            return winter_time\n",
            "\n",
            "    @tasks.loop(seconds=30)  # Проверяем каждые 30 секунд\n",
            "    async def check_event(self):\n",
            "        \"\"\"Проверяет, совпадает ли текущее время с расписанием событий.\"\"\"\n",
            "        now = datetime.now()  # Местное время\n",
            "        current_time = now.time().replace(second=0, microsecond=0)\n",
            "\n",
            "        if current_time in self.event_schedule:\n",
            "            # Проверяем, было ли уже отправлено сообщение для этого времени\n",
            "            if self.last_event_time == current_time:\n",
            "                return  # Прерываем выполнение, если сообщение уже отправлено\n",
            "\n",
            "            # Обновляем последнее время\n",
            "            self.last_event_time = current_time\n",
            "\n",
            "            # Получаем канал для отправки сообщения\n",
            "            channel = self.bot.get_channel(self.channel_id)\n",
            "            if channel:\n",
            "                role_ping = f\"<@&{self.role_id}>\"\n",
            "\n",
            "                # Вычисляем время начала события (реальное)\n",
            "                event_start = datetime.combine(now.date(), current_time)\n",
            "\n",
            "                # Добавляем 5 минут для отображения времени начала активности в эмбедде\n",
            "                event_start_plus_5 = event_start + timedelta(minutes=5)\n",
            "\n",
            "                embed = disnake.Embed(\n",
            "                    title=\"🌍 **Событие с гейзером скоро начнется!**\",\n",
            "                    description=\"Пришло время очистки гейзера на Островах укрытия. Торопитесь, чтобы получить как можно больше воска!\",\n",
            "                    color=disnake.Color.from_rgb(255, 182, 193)\n",
            "                )\n",
            "                embed.add_field(\n",
            "                    name=\"📅 Начало активности\",\n",
            "                    value=f\"{event_start_plus_5.strftime('%H:%M')}\",  # Показываем время на 5 минут позже\n",
            "                    inline=False\n",
            "                )\n",
            "                embed.add_field(\n",
            "                    name=\"⏳ Длительность активности\",\n",
            "                    value=\"10 минут\",\n",
            "                    inline=False\n",
            "                )\n",
            "                embed.set_image(url=self.image_url)\n",
            "                embed.set_footer(text=f\"Sky CotL\")\n",
            "\n",
            "                # Отправляем сообщение с пингом роли и embed'ом\n",
            "                await channel.send(content=role_ping, embed=embed)\n",
            "\n",
            "            else:\n",
            "                logging.error(f\"Канал с ID {self.channel_id} не найден.\")\n",
            "    \n",
            "    @check_event.before_loop\n",
            "    async def before_check_event(self):\n",
            "        \"\"\"Ждем, пока бот не будет готов перед запуском цикла.\"\"\"\n",
            "        await self.bot.wait_until_ready()\n",
            "\n",
            "\n",
            "def setup(bot: commands.Bot):\n",
            "    bot.add_cog(GeyserEvent(bot))\n"
        ]
    },
    "event/grandma_sky.py": {
        "hash": "d96b7f3ea97afb9f0d1fbcf7abecf865",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands, tasks\n",
            "from datetime import datetime, time, timedelta\n",
            "import logging\n",
            "import json\n",
            "import os\n",
            "\n",
            "# Настройка логирования\n",
            "logging.basicConfig(level=logging.INFO)\n",
            "\n",
            "class BabushkaEvent(commands.Cog):\n",
            "    def __init__(self, bot: commands.Bot):\n",
            "        self.bot = bot\n",
            "        # Загружаем ID канала и роли из JSON файла\n",
            "        self.config = self.load_config()\n",
            "        self.channel_id = self.config[\"channel_id\"]\n",
            "        self.role_id = self.config[\"role_id\"]\n",
            "        self.image_url = \"https://i.pinimg.com/736x/a8/b9/33/a8b93366dfd8bad4d4e50fdd840786f4.jpg\"  # Ссылка на изображение\n",
            "        self.event_schedule = self.get_event_schedule()  # Получение расписания\n",
            "        self.last_event_time = None  # Отслеживание последнего времени события\n",
            "\n",
            "        self.check_event.start()  # Запуск проверки событий\n",
            "\n",
            "    def load_config(self):\n",
            "        \"\"\"Загружает конфигурацию из JSON файла.\"\"\"\n",
            "        config_path = os.path.join(\"data\", \"event_sky.json\")\n",
            "        try:\n",
            "            with open(config_path, 'r', encoding='utf-8') as f:\n",
            "                return json.load(f)\n",
            "        except FileNotFoundError:\n",
            "            logging.error(f\"Файл конфигурации {config_path} не найден\")\n",
            "            return {\"channel_id\": 0, \"role_id\": 0}\n",
            "        except json.JSONDecodeError:\n",
            "            logging.error(f\"Ошибка при чтении файла конфигурации {config_path}\")\n",
            "            return {\"channel_id\": 0, \"role_id\": 0}\n",
            "\n",
            "    def get_event_schedule(self):\n",
            "        \"\"\"Расписание событий (московское время).\"\"\"\n",
            "        summer_time = [\n",
            "            time(10, 30), time(12, 30), time(14, 30), time(16, 30), time(18, 30),\n",
            "            time(20, 30), time(22, 30), time(0, 30), time(2, 30), time(4, 30),\n",
            "            time(6, 30), time(8, 30)\n",
            "        ]\n",
            "        winter_time = [\n",
            "            time(11, 30), time(13, 30), time(15, 30), time(17, 30), time(19, 30),\n",
            "            time(21, 30), time(23, 30), time(1, 30), time(3, 30), time(5, 30),\n",
            "            time(7, 30), time(9, 30)\n",
            "        ]\n",
            "\n",
            "        # Определяем, какое сейчас время года\n",
            "        now = datetime.now()\n",
            "        if (3, 15) <= (now.month, now.day) <= (11, 15):  # Летнее время\n",
            "            return summer_time\n",
            "        else:  # Зимнее время\n",
            "            return winter_time\n",
            "\n",
            "    @tasks.loop(seconds=30)  # Проверяем каждые 30 секунд\n",
            "    async def check_event(self):\n",
            "        \"\"\"Проверяет, совпадает ли текущее время с расписанием событий.\"\"\"\n",
            "        now = datetime.now()  # Местное время\n",
            "        current_time = now.time().replace(second=0, microsecond=0)\n",
            "\n",
            "        # Если событие уже отправлено для этого времени, пропускаем итерацию\n",
            "        if self.last_event_time == current_time:\n",
            "            return\n",
            "\n",
            "        if current_time in self.event_schedule:\n",
            "            # Обновляем последнее время\n",
            "            self.last_event_time = current_time\n",
            "\n",
            "            # Получаем канал для отправки сообщения\n",
            "            channel = self.bot.get_channel(self.channel_id)\n",
            "            if channel:\n",
            "                role_ping = f\"<@&{self.role_id}>\"\n",
            "\n",
            "                # Вычисляем время начала события (реальное)\n",
            "                event_start = datetime.combine(now.date(), current_time)\n",
            "\n",
            "                # Добавляем 5 минут для отображения времени начала активности в эмбедде\n",
            "                event_start_plus_5 = event_start + timedelta(minutes=5)\n",
            "\n",
            "                embed = disnake.Embed(\n",
            "                    title=\"⁣⁣ 🍙 **Событие с бабушкой скоро начнется!**\",\n",
            "                    description=\"Бабуля в Солнечном лесу уже напекла пирожков и ждет вас в гости. Торопитесь, чтобы получить как можно больше воска!\",\n",
            "                    color=disnake.Color.from_rgb(255, 182, 193)\n",
            "                )\n",
            "                embed.add_field(\n",
            "                    name=\"📅 Начало активности\",\n",
            "                    value=f\"{event_start_plus_5.strftime('%H:%M')}\",  # Показываем время на 5 минут позже\n",
            "                    inline=False\n",
            "                )\n",
            "                embed.add_field(\n",
            "                    name=\"⏳ Длительность активности\",\n",
            "                    value=\"10 минут\",\n",
            "                    inline=False\n",
            "                )\n",
            "                embed.set_image(url=self.image_url)\n",
            "                embed.set_footer(text=f\"Sky CotL\")\n",
            "\n",
            "                # Отправляем сообщение с пингом роли и embed'ом\n",
            "                await channel.send(content=role_ping, embed=embed)\n",
            "\n",
            "    @check_event.before_loop\n",
            "    async def before_check_event(self):\n",
            "        \"\"\"Ждем, пока бот не будет готов перед запуском цикла.\"\"\"\n",
            "        await self.bot.wait_until_ready()\n",
            "\n",
            "\n",
            "def setup(bot: commands.Bot):\n",
            "    bot.add_cog(BabushkaEvent(bot))\n"
        ]
    },
    "event/turtle_sky.py": {
        "hash": "ba7be6322932d33237fbd1155966da57",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands, tasks\n",
            "from datetime import datetime, time, timedelta\n",
            "import logging\n",
            "import json\n",
            "import os\n",
            "\n",
            "# Настройка логирования\n",
            "logging.basicConfig(level=logging.INFO)\n",
            "\n",
            "class TurtleEvent(commands.Cog):\n",
            "    def __init__(self, bot: commands.Bot):\n",
            "        self.bot = bot\n",
            "        # Загружаем ID канала и роли из JSON файла\n",
            "        self.config = self.load_config()\n",
            "        self.channel_id = self.config[\"channel_id\"]\n",
            "        self.role_id = self.config[\"role_id\"]\n",
            "        self.image_url = \"https://i.pinimg.com/736x/5b/4f/af/5b4faf4e54af4df1c1f636ebe1c9cf03.jpg\"  # Ссылка на изображение\n",
            "        self.event_schedule = self.get_event_schedule()  # Получение расписания\n",
            "        self.last_event_time = None  # Отслеживание последнего времени события\n",
            "\n",
            "        self.check_event.start()  # Запуск проверки событий\n",
            "\n",
            "    def load_config(self):\n",
            "        \"\"\"Загружает конфигурацию из JSON файла.\"\"\"\n",
            "        config_path = os.path.join(\"data\", \"event_sky.json\")\n",
            "        try:\n",
            "            with open(config_path, 'r', encoding='utf-8') as f:\n",
            "                return json.load(f)\n",
            "        except FileNotFoundError:\n",
            "            logging.error(f\"Файл конфигурации {config_path} не найден\")\n",
            "            return {\"channel_id\": 0, \"role_id\": 0}\n",
            "        except json.JSONDecodeError:\n",
            "            logging.error(f\"Ошибка при чтении файла конфигурации {config_path}\")\n",
            "            return {\"channel_id\": 0, \"role_id\": 0}\n",
            "\n",
            "    def get_event_schedule(self):\n",
            "        \"\"\"Расписание событий (московское время).\"\"\"\n",
            "        summer_time = [\n",
            "            time(10, 45), time(12, 45), time(14, 45), time(16, 45), time(18, 45),\n",
            "            time(20, 45), time(22, 45), time(0, 45), time(2, 45), time(4, 45),\n",
            "            time(6, 45), time(8, 45)\n",
            "        ]\n",
            "        winter_time = [\n",
            "            time(11, 45), time(13, 45), time(15, 45), time(17, 45), time(19, 45),\n",
            "            time(21, 45), time(23, 45), time(1, 45), time(3, 45), time(5, 45),\n",
            "            time(7, 45), time(9, 45)\n",
            "        ]\n",
            "\n",
            "        # Определяем, какое сейчас время года\n",
            "        now = datetime.now()\n",
            "        if (3, 15) <= (now.month, now.day) <= (11, 15):  # Летнее время\n",
            "            return summer_time\n",
            "        else:  # Зимнее время\n",
            "            return winter_time\n",
            "\n",
            "    @tasks.loop(seconds=30)  # Проверяем каждые 30 секунд\n",
            "    async def check_event(self):\n",
            "        \"\"\"Проверяет, совпадает ли текущее время с расписанием событий.\"\"\"\n",
            "        now = datetime.now()  # Местное время\n",
            "        current_time = now.time().replace(second=0, microsecond=0)\n",
            "\n",
            "        # Если событие уже отправлено для этого времени, пропускаем итерацию\n",
            "        if self.last_event_time == current_time:\n",
            "            return\n",
            "\n",
            "        if current_time in self.event_schedule:\n",
            "            # Обновляем последнее время\n",
            "            self.last_event_time = current_time\n",
            "\n",
            "            # Получаем канал для отправки сообщения\n",
            "            channel = self.bot.get_channel(self.channel_id)\n",
            "            if channel:\n",
            "                role_ping = f\"<@&{self.role_id}>\"\n",
            "\n",
            "                # Вычисляем время начала события (реальное)\n",
            "                event_start = datetime.combine(now.date(), current_time)\n",
            "\n",
            "                # Добавляем 5 минут для отображения времени начала активности в эмбедде\n",
            "                event_start_plus_5 = event_start + timedelta(minutes=5)\n",
            "\n",
            "                embed = disnake.Embed(\n",
            "                    title=\"⁣ 🐢 **Событие с черепахой скоро начнется!**\",\n",
            "                    description=\"Вас ждет сбор диковинных ракушек в закатных лучах Островов укрытия. Торопитесь, чтобы получить как можно больше воска!\",\n",
            "                    color=disnake.Color.from_rgb(255, 182, 193)\n",
            "                )\n",
            "                embed.add_field(\n",
            "                    name=\"📅 Начало активности\",\n",
            "                    value=f\"{event_start_plus_5.strftime('%H:%M')}\",  # Показываем время на 5 минут позже\n",
            "                    inline=False\n",
            "                )\n",
            "                embed.add_field(\n",
            "                    name=\"⏳ Длительность активности\",\n",
            "                    value=\"10 минут\",\n",
            "                    inline=False\n",
            "                )\n",
            "                embed.set_image(url=self.image_url)\n",
            "                embed.set_footer(text=f\"Sky CotL\")\n",
            "\n",
            "                # Отправляем сообщение с пингом роли и embed'ом\n",
            "                await channel.send(content=role_ping, embed=embed)\n",
            "\n",
            "    @check_event.before_loop\n",
            "    async def before_check_event(self):\n",
            "        \"\"\"Ждем, пока бот не будет готов перед запуском цикла.\"\"\"\n",
            "        await self.bot.wait_until_ready()\n",
            "\n",
            "\n",
            "def setup(bot: commands.Bot):\n",
            "    bot.add_cog(TurtleEvent(bot))\n"
        ]
    },
    "news/genshin_news.py": {
        "hash": "fd1e6a2447ce5de6a32e40c03e53206b",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from translate import Translator\n",
            "import re  # Для работы с регулярными выражениями\n",
            "import html  # Для декодирования HTML-символов\n",
            "from langdetect import detect  # Для определения языка\n",
            "import json\n",
            "import os\n",
            "\n",
            "class NewsGenshin(commands.Cog):\n",
            "    def __init__(self, bot: commands.Bot):\n",
            "        self.bot = bot\n",
            "        # Загружаем конфигурацию из JSON файла\n",
            "        self.config = self.load_config()\n",
            "        self.source_channel_id = self.config[\"source_channel_id\"]  # ID канала с новостями\n",
            "        self.target_channel_id = self.config[\"target_channel_id\"]  # ID канала для перевода\n",
            "        self.notify_role_id = self.config[\"notify_role_id\"]  # ID роли для пинга\n",
            "        self.translator = Translator(from_lang=\"en\", to_lang=\"ru\")  # Инициализация переводчика\n",
            "\n",
            "    def load_config(self):\n",
            "        \"\"\"Загружает конфигурацию из JSON файла.\"\"\"\n",
            "        config_path = os.path.join(\"data\", \"genshin_news.json\")\n",
            "        try:\n",
            "            with open(config_path, 'r', encoding='utf-8') as f:\n",
            "                return json.load(f)\n",
            "        except FileNotFoundError:\n",
            "            print(f\"Файл конфигурации {config_path} не найден\")\n",
            "            return {\n",
            "                \"source_channel_id\": 0,\n",
            "                \"target_channel_id\": 0,\n",
            "                \"notify_role_id\": 0\n",
            "            }\n",
            "        except json.JSONDecodeError:\n",
            "            print(f\"Ошибка при чтении файла конфигурации {config_path}\")\n",
            "            return {\n",
            "                \"source_channel_id\": 0,\n",
            "                \"target_channel_id\": 0,\n",
            "                \"notify_role_id\": 0\n",
            "            }\n",
            "\n",
            "    def clean_message(self, text):\n",
            "        \"\"\"Удаляет серверные эмодзи и стикеры из текста, оставляя стандартные эмодзи.\"\"\"\n",
            "        # Удаляем серверные эмодзи вида <:name:id> и <a:name:id>\n",
            "        text = re.sub(r\"<a?:\\w+:\\d+>\", \"\", text)\n",
            "        # Удаляем стикеры вида :stickerName:\n",
            "        text = re.sub(r\":\\w+:\", \"\", text)\n",
            "        # Убираем лишние пробелы\n",
            "        return text.strip()\n",
            "\n",
            "    def split_text(self, text, max_length=500):\n",
            "        \"\"\"Разделение текста на части, чтобы каждая была не длиннее max_length.\"\"\"\n",
            "        parts = []\n",
            "        while len(text) > max_length:\n",
            "            split_index = text.rfind(\" \", 0, max_length)\n",
            "            if split_index == -1:\n",
            "                split_index = max_length\n",
            "            parts.append(text[:split_index])\n",
            "            text = text[split_index:].strip()\n",
            "        parts.append(text)\n",
            "        return parts\n",
            "\n",
            "    def decode_html_entities(self, text):\n",
            "        \"\"\"Декодирует HTML-сущности, такие как &gt;, &lt;, &amp;.\"\"\"\n",
            "        return html.unescape(text)\n",
            "\n",
            "    def is_russian(self, text):\n",
            "        \"\"\"Проверяет, является ли текст на русском языке.\"\"\"\n",
            "        try:\n",
            "            return detect(text) == 'ru'\n",
            "        except:\n",
            "            return False\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_message(self, message: disnake.Message):\n",
            "        if message.channel.id != self.source_channel_id:\n",
            "            return\n",
            "\n",
            "        if message.author.bot and not message.webhook_id:\n",
            "            return\n",
            "\n",
            "        try:\n",
            "            # Если это обычное сообщение\n",
            "            if message.content.strip():\n",
            "                original_text = message.content.strip()\n",
            "                cleaned_text = self.clean_message(original_text)\n",
            "\n",
            "                # Проверяем, на каком языке текст\n",
            "                if self.is_russian(cleaned_text):\n",
            "                    print(\"Сообщение на русском, отправляем как есть.\")\n",
            "                    translated_text = cleaned_text\n",
            "                else:\n",
            "                    # Разделяем текст и переводим каждую часть\n",
            "                    translated_parts = [\n",
            "                        self.translator.translate(part)\n",
            "                        for part in self.split_text(cleaned_text)\n",
            "                    ]\n",
            "                    translated_text = \"\\n\\n\".join(translated_parts)\n",
            "\n",
            "                    # Декодируем HTML-сущности (например, &gt; -> >)\n",
            "                    translated_text = self.decode_html_entities(translated_text)\n",
            "\n",
            "                # Создаем embed для текста\n",
            "                embed = disnake.Embed(\n",
            "                    title=\"Genshin News\",\n",
            "                    description=translated_text,\n",
            "                    color=disnake.Color.from_rgb(255, 182, 193)  # Нежный розовый цвет\n",
            "                )\n",
            "\n",
            "                # Добавляем изображение из вложений\n",
            "                if message.attachments:\n",
            "                    for attachment in message.attachments:\n",
            "                        if attachment.content_type and attachment.content_type.startswith(\"image\"):\n",
            "                            embed.set_image(url=attachment.url)\n",
            "                            break\n",
            "\n",
            "                # Отправляем embed с пингом роли\n",
            "                target_channel = self.bot.get_channel(self.target_channel_id)\n",
            "                if target_channel:\n",
            "                    role_mention = f\"<@&{self.notify_role_id}>\"  # Упоминание роли\n",
            "                    await target_channel.send(\n",
            "                        content=role_mention,\n",
            "                        embed=embed,\n",
            "                        allowed_mentions=disnake.AllowedMentions(roles=True)  # Разрешаем пинг роли\n",
            "                    )\n",
            "                    print(f\"Сообщение отправлено: {translated_text}\")\n",
            "                else:\n",
            "                    print(\"Целевой канал не найден.\")\n",
            "\n",
            "            # Если это embed-сообщение\n",
            "            if message.embeds:\n",
            "                for embed in message.embeds:\n",
            "                    # Переводим описание и заголовок embed, если они не на русском\n",
            "                    if embed.title and not self.is_russian(embed.title):\n",
            "                        translated_title = self.translator.translate(embed.title)\n",
            "                    else:\n",
            "                        translated_title = embed.title\n",
            "\n",
            "                    if embed.description and not self.is_russian(embed.description):\n",
            "                        translated_description = self.translator.translate(embed.description)\n",
            "                    else:\n",
            "                        translated_description = embed.description\n",
            "\n",
            "                    # Декодируем HTML-сущности\n",
            "                    translated_title = self.decode_html_entities(translated_title) if translated_title else None\n",
            "                    translated_description = self.decode_html_entities(translated_description) if translated_description else None\n",
            "\n",
            "                    # Создаем новый переведенный embed\n",
            "                    translated_embed = disnake.Embed(\n",
            "                        title=translated_title,\n",
            "                        description=translated_description,\n",
            "                        color=disnake.Color.from_rgb(255, 182, 193)  # Нежный розовый цвет\n",
            "                    )\n",
            "\n",
            "                    # Добавляем изображение из оригинального embed (если есть)\n",
            "                    if embed.image and embed.image.url:\n",
            "                        translated_embed.set_image(url=embed.image.url)\n",
            "\n",
            "                    # Добавляем дополнительные элементы, такие как thumbnail, footer, author и поля\n",
            "                    if embed.thumbnail and embed.thumbnail.url:\n",
            "                        translated_embed.set_thumbnail(url=embed.thumbnail.url)\n",
            "\n",
            "                    if embed.footer:\n",
            "                        translated_embed.set_footer(text=self.translator.translate(embed.footer.text))\n",
            "\n",
            "                    if embed.author:\n",
            "                        translated_embed.set_author(name=self.translator.translate(embed.author.name))\n",
            "\n",
            "                    for field in embed.fields:\n",
            "                        translated_embed.add_field(\n",
            "                            name=self.translator.translate(field.name),\n",
            "                            value=self.translator.translate(field.value),\n",
            "                            inline=field.inline\n",
            "                        )\n",
            "\n",
            "                    # Отправляем переведенный embed в канал\n",
            "                    target_channel = self.bot.get_channel(self.target_channel_id)\n",
            "                    if target_channel:\n",
            "                        role_mention = f\"<@&{self.notify_role_id}>\"  # Упоминание роли\n",
            "                        await target_channel.send(\n",
            "                            content=role_mention,\n",
            "                            embed=translated_embed,\n",
            "                            allowed_mentions=disnake.AllowedMentions(roles=True)  # Разрешаем пинг роли\n",
            "                        )\n",
            "                        print(\"Переведенный embed отправлен.\")\n",
            "                    else:\n",
            "                        print(\"Целевой канал не найден.\")\n",
            "\n",
            "        except Exception as e:\n",
            "            print(f\"Ошибка при обработке сообщения: {e}\")\n",
            "\n",
            "def setup(bot: commands.Bot):\n",
            "    bot.add_cog(NewsGenshin(bot))\n"
        ]
    },
    "news/honkai_news.py": {
        "hash": "3ef31905ffa2ee4f5c79b06a54476a59",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from translate import Translator\n",
            "import re  # Для работы с регулярными выражениями\n",
            "import html  # Для декодирования HTML-символов\n",
            "from langdetect import detect  # Для определения языка\n",
            "import json\n",
            "import os\n",
            "\n",
            "class NewsHonkai(commands.Cog):\n",
            "    def __init__(self, bot: commands.Bot):\n",
            "        self.bot = bot\n",
            "        # Загружаем конфигурацию из JSON файла\n",
            "        self.config = self.load_config()\n",
            "        self.source_channel_id = self.config[\"source_channel_id\"]  # ID канала с новостями\n",
            "        self.target_channel_id = self.config[\"target_channel_id\"]  # ID канала для перевода\n",
            "        self.notify_role_id = self.config[\"notify_role_id\"]  # ID роли для пинга\n",
            "        self.translator = Translator(from_lang=\"en\", to_lang=\"ru\")  # Инициализация переводчика\n",
            "\n",
            "    def load_config(self):\n",
            "        \"\"\"Загружает конфигурацию из JSON файла.\"\"\"\n",
            "        config_path = os.path.join(\"data\", \"honkai_news.json\")\n",
            "        try:\n",
            "            with open(config_path, 'r', encoding='utf-8') as f:\n",
            "                return json.load(f)\n",
            "        except FileNotFoundError:\n",
            "            print(f\"Файл конфигурации {config_path} не найден\")\n",
            "            return {\n",
            "                \"source_channel_id\": 0,\n",
            "                \"target_channel_id\": 0,\n",
            "                \"notify_role_id\": 0\n",
            "            }\n",
            "        except json.JSONDecodeError:\n",
            "            print(f\"Ошибка при чтении файла конфигурации {config_path}\")\n",
            "            return {\n",
            "                \"source_channel_id\": 0,\n",
            "                \"target_channel_id\": 0,\n",
            "                \"notify_role_id\": 0\n",
            "            }\n",
            "\n",
            "    def clean_message(self, text):\n",
            "        \"\"\"Удаляет серверные эмодзи и стикеры из текста, оставляя стандартные эмодзи.\"\"\"\n",
            "        # Удаляем серверные эмодзи вида <:name:id> и <a:name:id>\n",
            "        text = re.sub(r\"<a?:\\w+:\\d+>\", \"\", text)\n",
            "        # Удаляем стикеры вида :stickerName:\n",
            "        text = re.sub(r\":\\w+:\", \"\", text)\n",
            "        # Убираем лишние пробелы\n",
            "        return text.strip()\n",
            "\n",
            "    def split_text(self, text, max_length=500):\n",
            "        \"\"\"Разделение текста на части, чтобы каждая была не длиннее max_length.\"\"\"\n",
            "        parts = []\n",
            "        while len(text) > max_length:\n",
            "            split_index = text.rfind(\" \", 0, max_length)\n",
            "            if split_index == -1:\n",
            "                split_index = max_length\n",
            "            parts.append(text[:split_index])\n",
            "            text = text[split_index:].strip()\n",
            "        parts.append(text)\n",
            "        return parts\n",
            "\n",
            "    def decode_html_entities(self, text):\n",
            "        \"\"\"Декодирует HTML-сущности, такие как &gt;, &lt;, &amp;.\"\"\"\n",
            "        return html.unescape(text)\n",
            "\n",
            "    def is_russian(self, text):\n",
            "        \"\"\"Проверяет, является ли текст на русском языке.\"\"\"\n",
            "        try:\n",
            "            return detect(text) == 'ru'\n",
            "        except:\n",
            "            return False\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_message(self, message: disnake.Message):\n",
            "        if message.channel.id != self.source_channel_id:\n",
            "            return\n",
            "\n",
            "        if message.author.bot and not message.webhook_id:\n",
            "            return\n",
            "\n",
            "        try:\n",
            "            # Если это обычное сообщение\n",
            "            if message.content.strip():\n",
            "                original_text = message.content.strip()\n",
            "                cleaned_text = self.clean_message(original_text)\n",
            "\n",
            "                # Проверяем, на каком языке текст\n",
            "                if self.is_russian(cleaned_text):\n",
            "                    print(\"Сообщение на русском, отправляем как есть.\")\n",
            "                    translated_text = cleaned_text\n",
            "                else:\n",
            "                    # Разделяем текст и переводим каждую часть\n",
            "                    translated_parts = [\n",
            "                        self.translator.translate(part)\n",
            "                        for part in self.split_text(cleaned_text)\n",
            "                    ]\n",
            "                    translated_text = \"\\n\\n\".join(translated_parts)\n",
            "\n",
            "                    # Декодируем HTML-сущности (например, &gt; -> >)\n",
            "                    translated_text = self.decode_html_entities(translated_text)\n",
            "\n",
            "                # Создаем embed для текста\n",
            "                embed = disnake.Embed(\n",
            "                    title=\"Honkai News\",\n",
            "                    description=translated_text,\n",
            "                    color=disnake.Color.from_rgb(255, 182, 193)  # Нежный розовый цвет\n",
            "                )\n",
            "\n",
            "                # Добавляем изображение из вложений\n",
            "                if message.attachments:\n",
            "                    for attachment in message.attachments:\n",
            "                        if attachment.content_type and attachment.content_type.startswith(\"image\"):\n",
            "                            embed.set_image(url=attachment.url)\n",
            "                            break\n",
            "\n",
            "                # Отправляем embed с пингом роли\n",
            "                target_channel = self.bot.get_channel(self.target_channel_id)\n",
            "                if target_channel:\n",
            "                    role_mention = f\"<@&{self.notify_role_id}>\"  # Упоминание роли\n",
            "                    await target_channel.send(\n",
            "                        content=role_mention,\n",
            "                        embed=embed,\n",
            "                        allowed_mentions=disnake.AllowedMentions(roles=True)  # Разрешаем пинг роли\n",
            "                    )\n",
            "                    print(f\"Сообщение отправлено: {translated_text}\")\n",
            "                else:\n",
            "                    print(\"Целевой канал не найден.\")\n",
            "\n",
            "            # Если это embed-сообщение\n",
            "            if message.embeds:\n",
            "                for embed in message.embeds:\n",
            "                    # Переводим описание и заголовок embed, если они не на русском\n",
            "                    if embed.title and not self.is_russian(embed.title):\n",
            "                        translated_title = self.translator.translate(embed.title)\n",
            "                    else:\n",
            "                        translated_title = embed.title\n",
            "\n",
            "                    if embed.description and not self.is_russian(embed.description):\n",
            "                        translated_description = self.translator.translate(embed.description)\n",
            "                    else:\n",
            "                        translated_description = embed.description\n",
            "\n",
            "                    # Декодируем HTML-сущности\n",
            "                    translated_title = self.decode_html_entities(translated_title) if translated_title else None\n",
            "                    translated_description = self.decode_html_entities(translated_description) if translated_description else None\n",
            "\n",
            "                    # Создаем новый переведенный embed\n",
            "                    translated_embed = disnake.Embed(\n",
            "                        title=translated_title,\n",
            "                        description=translated_description,\n",
            "                        color=disnake.Color.from_rgb(255, 182, 193)  # Нежный розовый цвет\n",
            "                    )\n",
            "\n",
            "                    # Добавляем изображение из оригинального embed (если есть)\n",
            "                    if embed.image and embed.image.url:\n",
            "                        translated_embed.set_image(url=embed.image.url)\n",
            "\n",
            "                    # Добавляем дополнительные элементы, такие как thumbnail, footer, author и поля\n",
            "                    if embed.thumbnail and embed.thumbnail.url:\n",
            "                        translated_embed.set_thumbnail(url=embed.thumbnail.url)\n",
            "\n",
            "                    if embed.footer:\n",
            "                        translated_embed.set_footer(text=self.translator.translate(embed.footer.text))\n",
            "\n",
            "                    if embed.author:\n",
            "                        translated_embed.set_author(name=self.translator.translate(embed.author.name))\n",
            "\n",
            "                    for field in embed.fields:\n",
            "                        translated_embed.add_field(\n",
            "                            name=self.translator.translate(field.name),\n",
            "                            value=self.translator.translate(field.value),\n",
            "                            inline=field.inline\n",
            "                        )\n",
            "\n",
            "                    # Отправляем переведенный embed в канал\n",
            "                    target_channel = self.bot.get_channel(self.target_channel_id)\n",
            "                    if target_channel:\n",
            "                        role_mention = f\"<@&{self.notify_role_id}>\"  # Упоминание роли\n",
            "                        await target_channel.send(\n",
            "                            content=role_mention,\n",
            "                            embed=translated_embed,\n",
            "                            allowed_mentions=disnake.AllowedMentions(roles=True)  # Разрешаем пинг роли\n",
            "                        )\n",
            "                        print(\"Переведенный embed отправлен.\")\n",
            "                    else:\n",
            "                        print(\"Целевой канал не найден.\")\n",
            "\n",
            "        except Exception as e:\n",
            "            print(f\"Ошибка при обработке сообщения: {e}\")\n",
            "\n",
            "def setup(bot: commands.Bot):\n",
            "    bot.add_cog(NewsHonkai(bot))\n"
        ]
    },
    "news/sky_news.py": {
        "hash": "949897a2ab20a9477bcd0d5b09af8170",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from translate import Translator\n",
            "import re\n",
            "import html\n",
            "from langdetect import detect\n",
            "import json\n",
            "import os\n",
            "\n",
            "class NewsSky(commands.Cog):\n",
            "    def __init__(self, bot: commands.Bot):\n",
            "        self.bot = bot\n",
            "        # Загружаем конфигурацию из JSON файла\n",
            "        self.config = self.load_config()\n",
            "        self.source_channel_id = self.config[\"source_channel_id\"]  # ID канала с новостями\n",
            "        self.target_channel_id = self.config[\"target_channel_id\"]  # ID канала для перевода \n",
            "        self.notify_role_id = self.config[\"notify_role_id\"]  # ID роли для пинга\n",
            "        self.translator = Translator(from_lang=\"en\", to_lang=\"ru\")  # Инициализация переводчика\n",
            "\n",
            "    def load_config(self):\n",
            "        \"\"\"Загружает конфигурацию из JSON файла.\"\"\"\n",
            "        config_path = os.path.join(\"data\", \"sky_news.json\")\n",
            "        try:\n",
            "            with open(config_path, 'r', encoding='utf-8') as f:\n",
            "                return json.load(f)\n",
            "        except FileNotFoundError:\n",
            "            print(f\"Файл конфигурации {config_path} не найден\")\n",
            "            return {\n",
            "                \"source_channel_id\": 0,\n",
            "                \"target_channel_id\": 0,\n",
            "                \"notify_role_id\": 0\n",
            "            }\n",
            "        except json.JSONDecodeError:\n",
            "            print(f\"Ошибка при чтении файла конфигурации {config_path}\")\n",
            "            return {\n",
            "                \"source_channel_id\": 0,\n",
            "                \"target_channel_id\": 0,\n",
            "                \"notify_role_id\": 0\n",
            "            }\n",
            "\n",
            "    def preserve_time_tags(self, text):\n",
            "        \"\"\"Заменяет метки времени на уникальные маркеры для сохранения.\"\"\"\n",
            "        time_tags = re.findall(r\"<t:\\d+(:[a-zA-Z]+)?>\", text)\n",
            "        preserved_text = text\n",
            "        for idx, tag in enumerate(time_tags):\n",
            "            preserved_text = preserved_text.replace(tag, f\"{{TIME_TAG_{idx}}}\")\n",
            "        return preserved_text, time_tags\n",
            "\n",
            "    def restore_time_tags(self, text, time_tags):\n",
            "        \"\"\"Восстанавливает метки времени в исходных местах текста.\"\"\"\n",
            "        for idx, tag in enumerate(time_tags):\n",
            "            text = text.replace(f\"{{TIME_TAG_{idx}}}\", tag)\n",
            "        return text\n",
            "\n",
            "    def clean_message(self, text):\n",
            "        \"\"\"Удаляет серверные эмодзи и стикеры из текста, оставляя стандартные эмодзи.\"\"\"\n",
            "        text = re.sub(r\"<a?:\\w+:\\d+>\", \"\", text)\n",
            "        text = re.sub(r\":\\w+:\", \"\", text)\n",
            "        return text.strip()\n",
            "\n",
            "    def split_text(self, text, max_length=500):\n",
            "        \"\"\"Разделение текста на части, чтобы каждая была не длиннее max_length.\"\"\"\n",
            "        parts = []\n",
            "        while len(text) > max_length:\n",
            "            split_index = text.rfind(\" \", 0, max_length)\n",
            "            if split_index == -1:\n",
            "                split_index = max_length\n",
            "            parts.append(text[:split_index])\n",
            "            text = text[split_index:].strip()\n",
            "        parts.append(text)\n",
            "        return parts\n",
            "\n",
            "    def decode_html_entities(self, text):\n",
            "        \"\"\"Декодирует HTML-сущности, такие как &gt;, &lt;, &amp;.\"\"\"\n",
            "        return html.unescape(text)\n",
            "\n",
            "    def is_russian(self, text):\n",
            "        \"\"\"Проверяет, является ли текст на русском языке.\"\"\"\n",
            "        try:\n",
            "            return detect(text) == 'ru'\n",
            "        except:\n",
            "            return False\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_message(self, message: disnake.Message):\n",
            "        # Игнорируем сообщения не из нужного канала и от ботов\n",
            "        if message.channel.id != self.source_channel_id:\n",
            "            return\n",
            "        if message.author.bot and not message.webhook_id:\n",
            "            return\n",
            "\n",
            "        try:\n",
            "            # Если это сообщение с вложенными автоэмбедами (которые Discord создает для ссылок)\n",
            "            if message.embeds and not message.content.strip():\n",
            "                print(\"Сообщение содержит автоэмбед, пропускаем.\")\n",
            "                return\n",
            "\n",
            "            # Если это обычное текстовое сообщение с новостью\n",
            "            if message.content.strip():\n",
            "                original_text = message.content.strip()\n",
            "\n",
            "                # Сохраняем метки времени и очищаем текст\n",
            "                preserved_text, time_tags = self.preserve_time_tags(original_text)\n",
            "                cleaned_text = self.clean_message(preserved_text)\n",
            "\n",
            "                # Если это не русский текст, переводим\n",
            "                if not self.is_russian(cleaned_text):\n",
            "                    translated_parts = [\n",
            "                        self.translator.translate(part)\n",
            "                        for part in self.split_text(cleaned_text)\n",
            "                    ]\n",
            "                    translated_text = \"\\n\\n\".join(translated_parts)\n",
            "                    translated_text = self.decode_html_entities(translated_text)\n",
            "                else:\n",
            "                    translated_text = cleaned_text\n",
            "\n",
            "                # Восстанавливаем метки времени\n",
            "                translated_text = self.restore_time_tags(translated_text, time_tags)\n",
            "\n",
            "                # Создаем embed для текста\n",
            "                embed = disnake.Embed(\n",
            "                    title=\"Sky News\",\n",
            "                    description=translated_text,\n",
            "                    color=disnake.Color.from_rgb(255, 182, 193)  # Нежный розовый цвет\n",
            "                )\n",
            "\n",
            "                # Добавляем изображение из вложений, если оно есть\n",
            "                if message.attachments:\n",
            "                    for attachment in message.attachments:\n",
            "                        if attachment.content_type and attachment.content_type.startswith(\"image\"):\n",
            "                            embed.set_image(url=attachment.url)\n",
            "                            break\n",
            "\n",
            "                # Отправляем embed с пингом роли в канал\n",
            "                target_channel = self.bot.get_channel(self.target_channel_id)\n",
            "                if target_channel:\n",
            "                    role_mention = f\"<@&{self.notify_role_id}>\"  # Упоминание роли\n",
            "                    await target_channel.send(\n",
            "                        content=role_mention,\n",
            "                        embed=embed,\n",
            "                        allowed_mentions=disnake.AllowedMentions(roles=True)  # Разрешаем пинг роли\n",
            "                    )\n",
            "                    print(f\"Сообщение отправлено: {translated_text}\")\n",
            "                else:\n",
            "                    print(\"Целевой канал не найден.\")\n",
            "\n",
            "        except Exception as e:\n",
            "            print(f\"Ошибка при обработке сообщения: {e}\")\n",
            "\n",
            "def setup(bot: commands.Bot):\n",
            "    bot.add_cog(NewsSky(bot))\n"
        ]
    },
    "server_func/admin_logs.py": {
        "hash": "c7750f6679e2b9eb172de89d4122a2e9",
        "content": [
            "import disnake\n",
            "from disnake import Embed\n",
            "from disnake.ext import commands\n",
            "import json\n",
            "\n",
            "class RoleAndMessageLogs(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        with open(\"conf/config.json\", \"r\") as f:\n",
            "            config = json.load(f)\n",
            "        self.log_channel_id = config[\"ADMIN_LOG_CHANNEL\"]\n",
            "\n",
            "    async def send_log(self, embed: Embed):\n",
            "        \"\"\"Отправка логов в указанный канал.\"\"\"\n",
            "        if self.log_channel_id:\n",
            "            channel = self.bot.get_channel(self.log_channel_id)\n",
            "            if channel:\n",
            "                await channel.send(embed=embed)\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_message_edit(self, before: disnake.Message, after: disnake.Message):\n",
            "        \"\"\"Логирование событий редактирования сообщений.\"\"\"\n",
            "        if before.author.bot or before.content == after.content:\n",
            "            return  # Игнорируем ботов или если текст не изменился\n",
            "\n",
            "        embed = Embed(\n",
            "            title=\"📝 Сообщение отредактировано\",\n",
            "            color=disnake.Color.orange(),\n",
            "            timestamp=disnake.utils.utcnow()\n",
            "        )\n",
            "        embed.set_thumbnail(url=before.author.avatar.url if before.author.avatar else None)\n",
            "\n",
            "        # Форматирование текста в Markdown-блоки\n",
            "        embed.add_field(\n",
            "            name=\"Сообщение до изменения\", \n",
            "            value=f\"```{before.content[:1024]}```\" if before.content else \"```[Пусто]```\", \n",
            "            inline=False\n",
            "        )\n",
            "        embed.add_field(\n",
            "            name=\"Сообщение после изменения\", \n",
            "            value=f\"```{after.content[:1024]}```\" if after.content else \"```[Пусто]```\", \n",
            "            inline=False\n",
            "        )\n",
            "        embed.add_field(name=\"Автор\", value=before.author.mention, inline=False)\n",
            "        embed.add_field(name=\"Канал\", value=before.channel.mention, inline=False)\n",
            "        embed.add_field(\n",
            "            name=\"Действие\",\n",
            "            value=f\"[Перейти к сообщению](https://discord.com/channels/{before.guild.id}/{before.channel.id}/{before.id})\",\n",
            "            inline=False\n",
            "        )\n",
            "        embed.set_footer(\n",
            "            text=f\"Редактировал: {before.author.name} • {disnake.utils.utcnow().strftime('%d.%m.%Y %H:%M')}\",\n",
            "            icon_url=before.author.avatar.url if before.author.avatar else None\n",
            "        )\n",
            "        await self.send_log(embed)\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_member_update(self, before: disnake.Member, after: disnake.Member):\n",
            "        \"\"\"Логирование изменений ролей.\"\"\"\n",
            "        embed = Embed(color=disnake.Color.blurple(), timestamp=disnake.utils.utcnow())\n",
            "        embed.set_thumbnail(url=after.avatar.url if after.avatar else None)\n",
            "        embed.set_footer(\n",
            "            text=f\"[Role Logs]\",\n",
            "            icon_url=after.avatar.url if after.avatar else None\n",
            "        )\n",
            "\n",
            "        # Проверяем изменения ролей\n",
            "        before_roles = set(before.roles)\n",
            "        after_roles = set(after.roles)\n",
            "\n",
            "        added_roles = after_roles - before_roles\n",
            "        removed_roles = before_roles - after_roles\n",
            "\n",
            "        if added_roles:\n",
            "            role_names = ', '.join([role.mention for role in added_roles])\n",
            "            embed.title = \"✨ Роль добавлена\"\n",
            "            embed.add_field(name=\"Добавлено\", value=role_names, inline=False)\n",
            "        if removed_roles:\n",
            "            role_names = ', '.join([role.mention for role in removed_roles])\n",
            "            embed.title = \"❌ Роль удалена\"\n",
            "            embed.add_field(name=\"Удалено\", value=role_names, inline=False)\n",
            "\n",
            "        # Добавляем общую информацию\n",
            "        embed.add_field(name=\"Пользователь\", value=after.mention, inline=False)\n",
            "\n",
            "        # Отправляем лог только если есть изменения\n",
            "        if added_roles or removed_roles:\n",
            "            await self.send_log(embed)\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(RoleAndMessageLogs(bot))\n"
        ]
    },
    "server_func/level_system.py": {
        "hash": "2db1f4559e9a5e88534e2eb59a2bdc60",
        "content": [
            "import os\n",
            "import json\n",
            "from disnake.ext import commands\n",
            "from disnake import Embed\n",
            "import disnake\n",
            "\n",
            "class LevelSystem(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        # Получаем путь до корневой директории проекта\n",
            "        self.base_path = os.path.dirname(os.path.abspath(__file__))  # Путь до server_func\n",
            "        self.file_path = os.path.join(self.base_path, \"../data/member_level.json\")  # Путь к файлу в папке data\n",
            "        self.level_up_xp = 100  # Базовое количество опыта для повышения уровня\n",
            "        self.level_roles = {\n",
            "            5: \"784159073385840651\",  # Замените на реальные RoleID\n",
            "            15: \"1091074897473720501\",  # Замените на реальные RoleID\n",
            "            25: \"1091078506986885212\",  # Замените на реальные RoleID\n",
            "            35: \"1091079383210541066\",  # Замените на реальные RoleID\n",
            "            45: \"1091079976025075852\",  # Замените на реальные RoleID\n",
            "            55: \"1091080623478812724\"  # Замените на реальные RoleID\n",
            "            # Добавь свои уровни и соответствующие им RoleID\n",
            "        }\n",
            "\n",
            "        # Проверка на наличие файла\n",
            "        if not os.path.exists(self.file_path):\n",
            "            with open(self.file_path, \"w\") as file:\n",
            "                json.dump({}, file)\n",
            "\n",
            "    def read_data(self):\n",
            "        \"\"\"Чтение данных из JSON.\"\"\"\n",
            "        with open(self.file_path, \"r\") as file:\n",
            "            return json.load(file)\n",
            "\n",
            "    def write_data(self, data):\n",
            "        \"\"\"Запись данных в JSON.\"\"\"\n",
            "        with open(self.file_path, \"w\") as file:\n",
            "            json.dump(data, file, indent=4)\n",
            "\n",
            "    def add_user(self, user_id):\n",
            "        \"\"\"Добавление нового пользователя в JSON.\"\"\"\n",
            "        data = self.read_data()\n",
            "        if str(user_id) not in data:\n",
            "            data[str(user_id)] = {\n",
            "                \"xp\": 0, \n",
            "                \"level\": 1, \n",
            "                \"messages_sent\": 0, \n",
            "                \"level_ups_sent\": []  # Инициализация пустого списка для новых пользователей\n",
            "            }\n",
            "            self.write_data(data)\n",
            "\n",
            "    def update_user(self, user_id, xp_gain):\n",
            "        \"\"\"Обновление данных пользователя: опыт, сообщения, уровень.\"\"\"\n",
            "        data = self.read_data()\n",
            "        user_data = data.get(str(user_id))\n",
            "        \n",
            "        if not user_data:\n",
            "            self.add_user(user_id)\n",
            "            user_data = data[str(user_id)]\n",
            "\n",
            "        # Проверка наличия ключа 'level_ups_sent' и его создание при необходимости\n",
            "        if 'level_ups_sent' not in user_data:\n",
            "            user_data['level_ups_sent'] = []\n",
            "\n",
            "        # Обновляем данные\n",
            "        user_data[\"xp\"] += xp_gain\n",
            "        user_data[\"messages_sent\"] += 1\n",
            "        \n",
            "        # Квадратичное увеличение опыта\n",
            "        next_level_xp = self.level_up_xp * (user_data[\"level\"] ** 2)  # Квадратичное увеличение\n",
            "\n",
            "        # Проверка уровня\n",
            "        level_up_occurred = False\n",
            "        if user_data[\"xp\"] >= next_level_xp:\n",
            "            user_data[\"level\"] += 1\n",
            "            user_data[\"xp\"] -= next_level_xp  # Убираем избыточный опыт\n",
            "            level_up_occurred = True\n",
            "        \n",
            "        # Проверка, был ли уже отправлен уровень\n",
            "        if level_up_occurred and user_data[\"level\"] not in user_data[\"level_ups_sent\"]:\n",
            "            user_data[\"level_ups_sent\"].append(user_data[\"level\"])  # Записываем, что уровень был отправлен\n",
            "            data[str(user_id)] = user_data\n",
            "            self.write_data(data)\n",
            "            return user_data[\"level\"], True  # Уведомление должно быть отправлено\n",
            "        else:\n",
            "            data[str(user_id)] = user_data\n",
            "            self.write_data(data)\n",
            "            return user_data[\"level\"], False  # Уведомление не требуется\n",
            "\n",
            "    async def assign_role(self, member, level):\n",
            "        \"\"\"Выдача роли в зависимости от уровня.\"\"\"\n",
            "        role_id = self.level_roles.get(level)\n",
            "        if role_id:\n",
            "            role = member.guild.get_role(int(role_id))\n",
            "            if role:\n",
            "                await member.add_roles(role)\n",
            "                return role.name\n",
            "        return None\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_message(self, message):\n",
            "        \"\"\"Обработка сообщений участников.\"\"\"\n",
            "        if message.author.bot:\n",
            "            return  # Игнорируем сообщения ботов\n",
            "        \n",
            "        # Пропускаем начисление XP, если это слэш-команда\n",
            "        if hasattr(message, 'interaction') and message.interaction:\n",
            "            return  # Это слэш-команда, не начисляем XP\n",
            "\n",
            "        # Обработка обычных сообщений\n",
            "        user_id = message.author.id\n",
            "        xp_gain = 10  # Опыт за сообщение\n",
            "        self.add_user(user_id)  # Убедимся, что пользователь есть в базе\n",
            "        new_level, level_up_sent = self.update_user(user_id, xp_gain)\n",
            "        \n",
            "        # Отправка уведомления о повышении уровня, только если еще не отправлялось\n",
            "        if new_level > 1 and level_up_sent and message.channel:\n",
            "            member = message.guild.get_member(user_id)\n",
            "            role_name = await self.assign_role(member, new_level)\n",
            "\n",
            "            # Создаем Embed сообщение\n",
            "            embed = Embed(\n",
            "                title=\"\",  # Пустой заголовок\n",
            "                description=f\"🎉 {message.author.mention} достиг уровня {new_level}!\\n\\n\"\n",
            "                            f\"{f'**Роль за уровень:** {role_name}' if role_name else ''}\",\n",
            "                color=disnake.Color.from_rgb(255, 182, 193)  # Нежно-розовый цвет\n",
            "            )\n",
            "\n",
            "            # Отправляем Embed\n",
            "            await message.channel.send(embed=embed)\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_application_command(self, interaction):\n",
            "        \"\"\"Перехват слэш-команд.\"\"\"\n",
            "        # Просто игнорируем команды - нет начисления опыта\n",
            "        return\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(LevelSystem(bot))\n"
        ]
    },
    "server_func/self_roles.py": {
        "hash": "31f645823179a13c9645a463b6c25f76",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from disnake.ui import Button, View\n",
            "from disnake import Interaction\n",
            "import json\n",
            "\n",
            "with open('conf/config.json') as f:\n",
            "    config = json.load(f)\n",
            "\n",
            "class SelfRole(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "\n",
            "    async def send_embeds(self, channel: disnake.TextChannel):\n",
            "        \"\"\"Отправляет Embed'ы с кнопками в канал.\"\"\"\n",
            "        embeds = [\n",
            "            disnake.Embed(\n",
            "                title=\"🎭 Роли Сервера\",\n",
            "                description=\"🎭 Здесь вы можете ознакомиться с основными ролями, которые существуют на нашем сервере, а также получить некоторые из них 🎭\",\n",
            "                color=disnake.Color.blurple()\n",
            "            ),\n",
            "            disnake.Embed(\n",
            "                title=\"💎 Административные Роли 💎\",\n",
            "                description=( \n",
            "                    \"__Люди с этими ролями – представители администрации, следящие за порядком на сервере и занимающиеся его поддержкой и развитием:__\\n\\n\"\n",
            "                    \"<@&1294045225873833999> – глобальные администраторы на разных проектах, имеют полномочия на уровне владельца сервера\\n\\n\"\n",
            "                    \"<@&1294045970975428628> – главы сервера, которые имеют полный доступ ко всем настройкам\\n\\n\"\n",
            "                    \"<@&784160890761117767> – правая рука и личные помощники глав сервера\\n\\n\"\n",
            "                    \"<@&1025668964447158322> – админы сервера, которые решают различные вопросы и организуют ивенты\\n\\n\"\n",
            "                    \"<@&1253683368135233577> – стражи порядка, все видят и всех накажут по заслугам\"\n",
            "                ),\n",
            "                color=disnake.Color.gold()\n",
            "            ),\n",
            "            disnake.Embed(\n",
            "                title=\"✨ Роли Персонала ✨\",\n",
            "                description=( \n",
            "                    \"__Люди с этими ролями – управляющие игровыми категориями и ответственные за ведение новостных каналов:__\\n\\n\"\n",
            "                    \"<@&1105831610391216168> – владелец и руководитель категории <#784172182145466369>\\n\\n\"\n",
            "                    \"<@&1105831009808822374> – владелец и руководитель категории <#810212950932586527>\\n\\n\"\n",
            "                    \"<@&1142091411655770234> – владелец и руководитель категории <#1142092089098764358>\"\n",
            "                ),\n",
            "                color=disnake.Color.green()\n",
            "            ),\n",
            "            disnake.Embed(\n",
            "                title=\"🎮 Игровые Роли 🎮\",\n",
            "                description=( \n",
            "                    \"__На нашем сервере существуют специальные категории для различных игр, где вы можете общаться по внутриигровым вопросам и заводить друзей:__\\n\\n\"\n",
            "                    \"<@&791556122128678934> – категория по игре Sky: Children of Light\\n\\n\"\n",
            "                    \"<@&810915472664690689> – категория по игре Genshin Impact\\n\\n\"\n",
            "                    \"<@&1142091192222359573> – категория по игре Honkai: Star Rail\"\n",
            "                ),\n",
            "                color=disnake.Color.blue()\n",
            "            ),\n",
            "            disnake.Embed(\n",
            "                title=\"👥 Гендерные Роли 👥\",\n",
            "                description=( \n",
            "                    \"__При желании вы можете указать свой пол, выбрав подходящую роль:__\\n\\n\"\n",
            "                    \"<@&866427253490450492> – парень\\n\\n\"\n",
            "                    \"<@&866426767639183411> – девушка\"\n",
            "                ),\n",
            "                color=disnake.Color.purple()\n",
            "            ),\n",
            "            disnake.Embed(\n",
            "                title=\"🌸 Роли за Уровень 🌸\",\n",
            "                description=( \n",
            "                    \"Общаясь и взаимодействуя на нашем сервере, вы можете копить опыт активности и повышать свой **уровень**\\n\"\n",
            "                    \"За достижение определенного уровня вам автоматически будет выдаваться роль:\\n\\n\"\n",
            "                    \"<@&784159073385840651> – 5 уровень\\n\\n\"\n",
            "                    \"<@&1091074897473720501> – 15 уровень\\n\\n\"\n",
            "                    \"<@&1091078506986885212> – 25 уровень\\n\\n\"\n",
            "                    \"<@&1091079383210541066> – 35 уровень\\n\\n\"\n",
            "                    \"<@&1091079976025075852> – 45 уровень\\n\\n\"\n",
            "                    \"<@&1091080623478812724> – 55 уровень\\n\\n\"\n",
            "                    \"> Проверить текущий уровень можно командой **«/level»**\"\n",
            "                ),\n",
            "                color=disnake.Color.orange()\n",
            "            ),\n",
            "            disnake.Embed(\n",
            "                title=\"⚡️ Особые Роли ⚡️\",\n",
            "                description=( \n",
            "                    \"__На нашем сервере также есть ряд эксклюзивных ролей, которые можно получить за различные действия или напрямую от администрации:__\\n\\n\"\n",
            "                    \"<@&798286377757704212> – человек с доступом к бета-версиям игр, актуальных на сервере\\n\"\n",
            "                    \"`Способ получения: связаться с администрацией через #⭐┋𝚂𝚞𝚙𝚙𝚘𝚛𝚝 и предоставить запрашиваемые доказательства`\\n\\n\"\n",
            "                    \"<@&1266081292181835846> – друг сервера, оказывающий различную поддержку его развитию\\n\"\n",
            "                    \"`Способ получения: выдается на усмотрение администрации`\\n\\n\"\n",
            "                    \"<@&850536622062698527> – человек, оказавший личную материальную поддержку Бандикуту\\n\\n\"\n",
            "                    \"<@&854234816303595532> – человек, забустивший сервер\\n\\n\"\n",
            "                    \"<@&1261858451366346862> – роль, которая предоставляет доступ к различным плюшкам и дополнительным функциям\\n\"\n",
            "                    \"`Способ получения: покупка за серверную валюту у Akemi в канале` <#832814956499828766>\\n\\n\"\n",
            "                    \"<@&796308168719728651>  – роль для нарушителей, получивших мут по каким-либо причинам\\n\"\n",
            "                    \"`Бонус: открывает доступ к каналу <#1272281772092166214>, где можно выплеснуть эмоции или оспорить свое наказание`<:interesting:873242359482171422>\"\n",
            "                ),\n",
            "                color=disnake.Color.red()\n",
            "            ),\n",
            "            disnake.Embed(\n",
            "                title=\"⚠️ Дополнительные Роли ⚠️\",\n",
            "                description=( \n",
            "                    \"> Помимо вышеперечисленных ролей на нашем сервере присутствуют и другие\\n\"\n",
            "                    \"⚠️ Если интересующей вас роли нет в списке, значит она может быть __архивной__ и/или ее получение на данный момент **невозможно**\\n\\n\"\n",
            "                    \"Если у вас возникли вопросы по получению какой-либо роли, свяжитесь с нами в <#1253754782359752865>\"\n",
            "                ),\n",
            "                color=disnake.Color.dark_gray()\n",
            "            )\n",
            "        ]\n",
            "\n",
            "        # Создание кнопок для ролей\n",
            "        game_button_view = View()\n",
            "        game_button_view.add_item(Button(label=\"Sky: Children of Light\", custom_id=\"role_sky\", style=disnake.ButtonStyle.success))\n",
            "        game_button_view.add_item(Button(label=\"Genshin Impact\", custom_id=\"role_genshin\", style=disnake.ButtonStyle.success))\n",
            "        game_button_view.add_item(Button(label=\"Honkai: Star Rail\", custom_id=\"role_honkai\", style=disnake.ButtonStyle.success))\n",
            "        game_button_view.add_item(Button(label=\"Сбросить игровые роли\", custom_id=\"reset_game_roles\", style=disnake.ButtonStyle.danger))\n",
            "\n",
            "        gender_button_view = View()\n",
            "        gender_button_view.add_item(Button(label=\"Парень\", custom_id=\"role_male\", style=disnake.ButtonStyle.primary))\n",
            "        gender_button_view.add_item(Button(label=\"Девушка\", custom_id=\"role_female\", style=disnake.ButtonStyle.primary))\n",
            "        gender_button_view.add_item(Button(label=\"Сбросить гендерную роль\", custom_id=\"reset_gender_role\", style=disnake.ButtonStyle.danger))\n",
            "\n",
            "        # Кнопка сброса ролей\n",
            "        reset_button_view = View()\n",
            "        reset_button_view.add_item(Button(label=\"Сбросить роли\", custom_id=\"reset_roles\", style=disnake.ButtonStyle.danger))\n",
            "\n",
            "        # Отправка Embed'ов\n",
            "        for index, embed in enumerate(embeds):\n",
            "            if index == 3:  # Роли игр (4-й Embed)\n",
            "                await channel.send(embed=embed, view=game_button_view)\n",
            "            elif index == 4:  # Гендерные роли (5-й Embed)\n",
            "                await channel.send(embed=embed, view=gender_button_view)\n",
            "            else:\n",
            "                await channel.send(embed=embed)\n",
            "\n",
            "    @commands.slash_command(name=\"dev_role_welcome\", description=\"Отправляет сообщения с ролями для приветствия на сервере.\")\n",
            "    async def dev_role_welcome(self, inter: disnake.CommandInteraction, channel: disnake.TextChannel = None):\n",
            "        \"\"\"Команда для администраторов для отправки сообщений с ролями.\"\"\"\n",
            "        # Деферим ответ, чтобы избежать тайм-аута\n",
            "        await inter.response.defer()\n",
            "        # Проверка прав администратора\n",
            "        user_roles = [role.id for role in inter.user.roles]\n",
            "        allowed_roles = config[\"ADMIN\"]\n",
            "\n",
            "        if not any(role_id in user_roles for role_id in allowed_roles):\n",
            "            await inter.send(\"У вас нет прав для использования этой команды.\", ephemeral=True)\n",
            "            return\n",
            "        \n",
            "        # Если канал не указан, используем канал, в котором была вызвана команда\n",
            "        if not channel:\n",
            "            channel = inter.channel\n",
            "\n",
            "        # Отправка Embed'ов с ролями\n",
            "        await self.send_embeds(channel)\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_button_click(self, interaction: Interaction):\n",
            "        \"\"\"Обработчик нажатия кнопок для добавления ролей и сброса ролей.\"\"\"\n",
            "        role_mapping = {\n",
            "            \"role_sky\": 791556122128678934,  # Sky роль\n",
            "            \"role_genshin\": 810915472664690689,  # Genshin роль\n",
            "            \"role_honkai\": 1142091192222359573,  # Honkai роль\n",
            "            \"role_male\": 866427253490450492,  # Мужчина роль\n",
            "            \"role_female\": 866426767639183411,  # Женщина роль\n",
            "        }\n",
            "\n",
            "        role_id = role_mapping.get(interaction.data['custom_id'])\n",
            "\n",
            "        if role_id:\n",
            "            role = interaction.guild.get_role(role_id)\n",
            "            if role:\n",
            "                await interaction.user.add_roles(role)\n",
            "                await interaction.response.send_message(f\"Вам была выдана роль {role.name}!\", ephemeral=True)\n",
            "            else:\n",
            "                await interaction.response.send_message(\"Произошла ошибка при добавлении роли.\", ephemeral=True)\n",
            "\n",
            "        # Сброс игровых ролей\n",
            "        if interaction.data['custom_id'] == \"reset_game_roles\":\n",
            "            game_roles = [791556122128678934, 810915472664690689, 1142091192222359573]\n",
            "            roles_to_remove = [role for role in interaction.user.roles if role.id in game_roles]\n",
            "            if roles_to_remove:\n",
            "                await interaction.user.remove_roles(*roles_to_remove)\n",
            "                await interaction.response.send_message(\"Все игровые роли были сброшены!\", ephemeral=True)\n",
            "            else:\n",
            "                await interaction.response.send_message(\"У вас нет игровых ролей для сброса.\", ephemeral=True)\n",
            "\n",
            "        # Сброс гендерной роли\n",
            "        if interaction.data['custom_id'] == \"reset_gender_role\":\n",
            "            gender_roles = [866427253490450492, 866426767639183411]\n",
            "            roles_to_remove = [role for role in interaction.user.roles if role.id in gender_roles]\n",
            "            if roles_to_remove:\n",
            "                await interaction.user.remove_roles(*roles_to_remove)\n",
            "                await interaction.response.send_message(\"Ваша гендерная роль была сброшена!\", ephemeral=True)\n",
            "            else:\n",
            "                await interaction.response.send_message(\"У вас нет гендерной роли для сброса.\", ephemeral=True)\n",
            "\n",
            "        # Сброс всех ролей\n",
            "        if interaction.data['custom_id'] == \"reset_roles\":\n",
            "            for role in interaction.user.roles:\n",
            "                if role.id in role_mapping.values():\n",
            "                    await interaction.user.remove_roles(role)\n",
            "            await interaction.response.send_message(\"Все роли сброшены!\", ephemeral=True)\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(SelfRole(bot))\n"
        ]
    },
    "server_func/self_role_pings.py": {
        "hash": "45f6bbbda55ad9dd07185afa1122edb8",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from disnake.ui import Button, View\n",
            "from disnake import Interaction\n",
            "import json\n",
            "import os\n",
            "\n",
            "\n",
            "class SelfRolePings(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        self.config = self.load_config()\n",
            "        self.admin_roles = self.config.get(\"ADMIN\", [])\n",
            "\n",
            "    def load_config(self):\n",
            "        \"\"\"Загружает конфигурацию из JSON файла.\"\"\"\n",
            "        config_path = os.path.join(\"conf\", \"config.json\")\n",
            "        try:\n",
            "            with open(config_path, 'r', encoding='utf-8') as f:\n",
            "                return json.load(f)\n",
            "        except FileNotFoundError:\n",
            "            print(f\"Файл конфигурации {config_path} не найден\")\n",
            "            return {}\n",
            "        except json.JSONDecodeError:\n",
            "            print(f\"Ошибка при чтении файла конфигурации {config_path}\")\n",
            "            return {}\n",
            "\n",
            "    async def send_embeds(self, channel: disnake.TextChannel):\n",
            "        \"\"\"Отправляет Embed'ы с ролями новостей и событий для пинга.\"\"\"\n",
            "\n",
            "        # Первый эмбед (Роли для пинга новостей)\n",
            "        news_embed = disnake.Embed(\n",
            "            title=\"📰 Роли для пинга новостей\",\n",
            "            description=(\n",
            "                \"__Вы можете подписаться на новости по этим играм и получать уведомления, связанные с ними:__\\n\\n\"\n",
            "                \"<@&1311089355686805514> – пинг по новостям Sky: Children of Light\\n\\n\"\n",
            "                \"<@&1311189352533065808> – пинг по новостям Honkai: Star Rail\\n\\n\"\n",
            "                \"<@&1311189464730832977> – пинг по новостям Genshin Impact\"\n",
            "            ),\n",
            "            color=disnake.Color.blue()\n",
            "        )\n",
            "\n",
            "        # Второй эмбед (Роли для пинга событий в игре)\n",
            "        event_embed = disnake.Embed(\n",
            "            title=\"🎮 Роли для пинга событий в игре\",\n",
            "            description=(\n",
            "                \"__Получайте уведомления о событиях в игре Sky: Children of Light с этой ролью:__\\n\\n\"\n",
            "                \"<@&1311189081467916399> – пинг по событиям в игре Sky\"\n",
            "            ),\n",
            "            color=disnake.Color.green()\n",
            "        )\n",
            "\n",
            "        # Создание кнопок для первого эмбеда (новости)\n",
            "        news_button_view = View()\n",
            "        news_button_view.add_item(Button(label=\"Sky Новости\", custom_id=\"self_roles_role_sky_news\", style=disnake.ButtonStyle.primary))\n",
            "        news_button_view.add_item(Button(label=\"Honkai Новости\", custom_id=\"self_roles_role_honkai_news\", style=disnake.ButtonStyle.primary))\n",
            "        news_button_view.add_item(Button(label=\"Genshin Impact Новости\", custom_id=\"self_roles_role_genshin_news\", style=disnake.ButtonStyle.primary))\n",
            "        news_button_view.add_item(Button(label=\"Сбросить роли\", custom_id=\"self_roles_reset_news_roles\", style=disnake.ButtonStyle.danger))\n",
            "\n",
            "        # Создание кнопок для второго эмбеда (события)\n",
            "        event_button_view = View()\n",
            "        event_button_view.add_item(Button(label=\"Sky События\", custom_id=\"self_roles_role_sky_events\", style=disnake.ButtonStyle.primary))\n",
            "        event_button_view.add_item(Button(label=\"Сбросить роли\", custom_id=\"self_roles_reset_event_roles\", style=disnake.ButtonStyle.danger))\n",
            "\n",
            "        # Отправка Embed'ов с ролями\n",
            "        await channel.send(embed=news_embed, view=news_button_view)\n",
            "        await channel.send(embed=event_embed, view=event_button_view)\n",
            "\n",
            "    @commands.slash_command(name=\"self_roles\", description=\"Выберите роли для получения пингов.\")\n",
            "    async def self_roles(self, inter: disnake.CommandInteraction, channel: disnake.TextChannel = None):\n",
            "        \"\"\"Команда для выбора ролей для пинга новостей и событий.\"\"\"\n",
            "        await inter.response.defer()\n",
            "\n",
            "        user_roles = [role.id for role in inter.user.roles]\n",
            "\n",
            "        if not any(role_id in user_roles for role_id in self.admin_roles):\n",
            "            await inter.send(\"У вас нет прав для использования этой команды.\", ephemeral=True)\n",
            "            return\n",
            "\n",
            "        if not channel:\n",
            "            channel = inter.channel\n",
            "\n",
            "        await self.send_embeds(channel)\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_button_click(self, interaction: Interaction):\n",
            "        \"\"\"Обработчик нажатия кнопок для добавления ролей и сброса ролей.\"\"\"\n",
            "        if not interaction.data['custom_id'].startswith(\"self_roles_\"):\n",
            "            return  # Игнорируем кнопки, которые не относятся к SelfRolePings\n",
            "\n",
            "        role_mapping = {\n",
            "            \"self_roles_role_sky_news\": 1311089355686805514,\n",
            "            \"self_roles_role_honkai_news\": 1311189352533065808,\n",
            "            \"self_roles_role_genshin_news\": 1311189464730832977,\n",
            "            \"self_roles_role_sky_events\": 1311189081467916399,\n",
            "        }\n",
            "\n",
            "        custom_id = interaction.data['custom_id']\n",
            "        role_id = role_mapping.get(custom_id)\n",
            "\n",
            "        if role_id:\n",
            "            role = interaction.guild.get_role(role_id)\n",
            "            if role:\n",
            "                await interaction.user.add_roles(role)\n",
            "                await interaction.response.send_message(f\"Вам была выдана роль {role.name}!\", ephemeral=True)\n",
            "            else:\n",
            "                await interaction.response.send_message(\"Произошла ошибка при добавлении роли.\", ephemeral=True)\n",
            "            return\n",
            "\n",
            "        if custom_id == \"self_roles_reset_news_roles\":\n",
            "            news_roles = [1311089355686805514, 1311189352533065808, 1311189464730832977]\n",
            "            roles_to_remove = [role for role in interaction.user.roles if role.id in news_roles]\n",
            "\n",
            "            if roles_to_remove:\n",
            "                await interaction.user.remove_roles(*roles_to_remove)\n",
            "                await interaction.response.send_message(\"Все новости роли были сброшены!\", ephemeral=True)\n",
            "            else:\n",
            "                await interaction.response.send_message(\"У вас нет ролей для новостей для сброса.\", ephemeral=True)\n",
            "\n",
            "        elif custom_id == \"self_roles_reset_event_roles\":\n",
            "            event_roles = [1311189081467916399]\n",
            "            roles_to_remove = [role for role in interaction.user.roles if role.id in event_roles]\n",
            "\n",
            "            if roles_to_remove:\n",
            "                await interaction.user.remove_roles(*roles_to_remove)\n",
            "                await interaction.response.send_message(\"Все события роли были сброшены!\", ephemeral=True)\n",
            "            else:\n",
            "                await interaction.response.send_message(\"У вас нет ролей для событий для сброса.\", ephemeral=True)\n",
            "\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(SelfRolePings(bot))\n"
        ]
    },
    "server_func/server_info.py": {
        "hash": "4a74cbbef0ce038ffb283d209b82519a",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "\n",
            "class ServerInfo(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "\n",
            "    @commands.slash_command(name=\"server_info\", description=\"Получить информацию о сервере\")\n",
            "    async def server_info(self, interaction: disnake.ApplicationCommandInteraction):\n",
            "        \"\"\"Отправляет embed с полной информацией о сервере.\"\"\"\n",
            "\n",
            "        # Получаем информацию о сервере\n",
            "        guild = interaction.guild\n",
            "\n",
            "        # Создаем Embed с красивыми эмодзи и настройками\n",
            "        embed = disnake.Embed(\n",
            "            title=f\"Сервер {guild.name}\",\n",
            "            description=f\"🌟 **Краткая информация ^_^** 🌟\",\n",
            "            color=disnake.Color.blurple()\n",
            "        )\n",
            "\n",
            "        # Добавляем поля с информацией о сервере\n",
            "        embed.add_field(name=\"📅 Дата создания:\", value=guild.created_at.strftime('%d %B %Y, %H:%M:%S'))\n",
            "        embed.add_field(name=\"👥 Количество участников:\", value=guild.member_count)\n",
            "        embed.add_field(name=\"💬 Количество каналов:\", value=len(guild.text_channels) + len(guild.voice_channels))\n",
            "        embed.add_field(name=\"🤖 Количество ботов:\", value=len([member for member in guild.members if member.bot]))\n",
            "        embed.add_field(name=\"🌐 Локаль сервера:\", value=guild.preferred_locale)\n",
            "        embed.add_field(name=\"🎨 Роли на сервере:\", value=len(guild.roles))\n",
            "        \n",
            "        # Добавляем ссылку на серверный аватар и добавляем его справа сверху\n",
            "        embed.set_thumbnail(url=guild.icon.url)\n",
            "        embed.set_footer(text=f\"Запросил: {interaction.user.display_name}\", icon_url=interaction.user.display_avatar.url)\n",
            "\n",
            "        # Отправляем сообщение с Embed\n",
            "        await interaction.response.send_message(embed=embed)\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(ServerInfo(bot))\n"
        ]
    },
    "server_func/voice_logs.py": {
        "hash": "2dc960017503f4f4d4760f89c5ec9512",
        "content": [
            "import disnake\n",
            "from disnake import Embed\n",
            "from disnake.ext import commands\n",
            "import json\n",
            "\n",
            "class VoiceLogs(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        with open('conf/config.json', 'r', encoding='utf-8') as f:\n",
            "            self.config = json.load(f)\n",
            "        self.voice_log_channel_id = self.config[\"voice_log_channel\"]\n",
            "\n",
            "    async def send_log(self, embed: Embed):\n",
            "        if self.voice_log_channel_id:\n",
            "            channel = self.bot.get_channel(self.voice_log_channel_id)\n",
            "            if channel:\n",
            "                await channel.send(embed=embed)\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_voice_state_update(self, member: disnake.Member, before: disnake.VoiceState, after: disnake.VoiceState):\n",
            "        embed = Embed(color=disnake.Color.blurple(), timestamp=disnake.utils.utcnow())\n",
            "        embed.set_author(name=f\"{member.name}#{member.discriminator}\", icon_url=member.avatar.url if member.avatar else None)\n",
            "        embed.set_thumbnail(url=member.avatar.url if member.avatar else None)\n",
            "\n",
            "        # Join/Leave Events\n",
            "        if before.channel != after.channel:\n",
            "            if before.channel is None:\n",
            "                embed.title = \"Пользователь присоединился к голосовому каналу\"\n",
            "                embed.description = (\n",
            "                    f\"**{member.mention}** присоединился к каналу:\\n\"\n",
            "                    f\"🔊 **{after.channel.name}** *(ID: {after.channel.id})*\"\n",
            "                )\n",
            "                embed.color = disnake.Color.green()\n",
            "            elif after.channel is None:\n",
            "                embed.title = \"Пользователь покинул голосовой канал\"\n",
            "                embed.description = (\n",
            "                    f\"**{member.mention}** покинул канал:\\n\"\n",
            "                    f\"🔊 **{before.channel.name}** *(ID: {before.channel.id})*\"\n",
            "                )\n",
            "                embed.color = disnake.Color.red()\n",
            "            else:\n",
            "                embed.title = \"Пользователь переключился между голосовыми каналами\"\n",
            "                embed.description = (\n",
            "                    f\"**{member.mention}** переключился:\\n\"\n",
            "                    f\"🔊 Из канала **{before.channel.name}** *(ID: {before.channel.id})*\\n\"\n",
            "                    f\"➡️ В канал **{after.channel.name}** *(ID: {after.channel.id})*\"\n",
            "                )\n",
            "                embed.color = disnake.Color.orange()\n",
            "\n",
            "        # Mute/Unmute Events\n",
            "        if before.self_mute != after.self_mute:\n",
            "            embed.title = \"Событие: Изменение состояния микрофона\"\n",
            "            embed.description = (\n",
            "                f\"**{member.mention}** {'🔇 заглушил' if after.self_mute else '🔊 включил'} микрофон.\\n\"\n",
            "                f\"Текущий канал: **{after.channel.name if after.channel else 'Не в канале'}**\"\n",
            "            )\n",
            "            embed.color = disnake.Color.purple()\n",
            "\n",
            "        # Deafen/Undeafen Events\n",
            "        if before.self_deaf != after.self_deaf:\n",
            "            embed.title = \"Событие: Изменение состояния звука\"\n",
            "            embed.description = (\n",
            "                f\"**{member.mention}** {'🔇 заглушил звук' if after.self_deaf else '🔊 включил звук'} для себя.\\n\"\n",
            "                f\"Текущий канал: **{after.channel.name if after.channel else 'Не в канале'}**\"\n",
            "            )\n",
            "            embed.color = disnake.Color.teal()\n",
            "\n",
            "        # Stream Events\n",
            "        if before.self_stream != after.self_stream:\n",
            "            embed.title = \"Событие: Стриминг\"\n",
            "            embed.description = (\n",
            "                f\"**{member.mention}** {'📺 начал стримить' if after.self_stream else '📴 закончил стрим'}.\\n\"\n",
            "                f\"Текущий канал: **{after.channel.name if after.channel else 'Не в канале'}**\"\n",
            "            )\n",
            "            embed.color = disnake.Color.gold()\n",
            "\n",
            "        # Camera Events\n",
            "        if before.self_video != after.self_video:\n",
            "            embed.title = \"Событие: Камера\"\n",
            "            embed.description = (\n",
            "                f\"**{member.mention}** {'📹 включил камеру' if after.self_video else '📴 выключил камеру'}.\\n\"\n",
            "                f\"Текущий канал: **{after.channel.name if after.channel else 'Не в канале'}**\"\n",
            "            )\n",
            "            embed.color = disnake.Color.magenta()\n",
            "\n",
            "        # Send the log if any relevant changes occurred\n",
            "        if embed.description:\n",
            "            embed.set_footer(\n",
            "                text=f\"ID пользователя: {member.id}\",\n",
            "                icon_url=self.bot.user.avatar.url if self.bot.user.avatar else None\n",
            "            )\n",
            "            await self.send_log(embed)\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(VoiceLogs(bot))\n"
        ]
    },
    "user_func/activity_day.py": {
        "hash": "3e901a270aa44352c6efe8de2272c02a",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands, tasks\n",
            "from datetime import datetime, time\n",
            "import json\n",
            "import os\n",
            "\n",
            "class ServerActivity(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        self.daily_message_count = self.load_activity_data()\n",
            "        self.reset_daily_activity.start()  # Запуск задачи сброса данных\n",
            "\n",
            "    def load_activity_data(self):\n",
            "        # Загрузка данных из файла activity_day.json или инициализация пустого словаря\n",
            "        if os.path.exists(\"data/activity_day.json\"):\n",
            "            try:\n",
            "                with open(\"data/activity_day.json\", \"r\") as f:\n",
            "                    return json.load(f)\n",
            "            except json.JSONDecodeError:\n",
            "                # Если файл пуст или повреждён, возвращаем пустой словарь\n",
            "                print(\"Файл activity_day.json пуст или повреждён. Инициализация пустого словаря.\")\n",
            "                return {}\n",
            "        return {}\n",
            "\n",
            "    def save_activity_data(self):\n",
            "        # Сохранение данных в файл activity_day.json\n",
            "        with open(\"data/activity_day.json\", \"w\") as f:\n",
            "            json.dump(self.daily_message_count, f)\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_message(self, message: disnake.Message):\n",
            "        # Игнорировать сообщения бота и ботов\n",
            "        if message.author == self.bot.user or message.author.bot:\n",
            "            return\n",
            "\n",
            "        # Получаем текущую дату в формате строки\n",
            "        today = datetime.now().strftime('%Y-%m-%d')\n",
            "\n",
            "        # Инициализация данных по сообщениям для текущего дня\n",
            "        if today not in self.daily_message_count:\n",
            "            self.daily_message_count[today] = {}\n",
            "\n",
            "        # Увеличение счётчика сообщений для пользователя\n",
            "        user_id = str(message.author.id)\n",
            "        if user_id not in self.daily_message_count[today]:\n",
            "            self.daily_message_count[today][user_id] = 0\n",
            "        self.daily_message_count[today][user_id] += 1\n",
            "\n",
            "        # Сохранение данных в файл\n",
            "        self.save_activity_data()\n",
            "\n",
            "    @commands.slash_command(description=\"Показать активность сервера за текущий день.\")\n",
            "    async def server_activity_day(self, inter: disnake.ApplicationCommandInteraction):\n",
            "        today = datetime.now().strftime('%Y-%m-%d')\n",
            "        \n",
            "        # Загрузка конфигурации\n",
            "        with open(\"conf/config.json\", \"r\") as f:\n",
            "            config = json.load(f)\n",
            "        \n",
            "        # Проверка, есть ли данные за сегодня\n",
            "        if today not in self.daily_message_count or not self.daily_message_count[today]:\n",
            "            await inter.send(\"Сегодня ещё нет данных для активности участников.\", ephemeral=True)\n",
            "            return\n",
            "\n",
            "        # Сортировка участников по количеству сообщений\n",
            "        sorted_users = sorted(\n",
            "            self.daily_message_count[today].items(),\n",
            "            key=lambda item: item[1],\n",
            "            reverse=True\n",
            "        )\n",
            "        \n",
            "        # Ограничиваем вывод до топ-10 участников\n",
            "        top_10_users = sorted_users[:10]\n",
            "\n",
            "        # Создание embed для вывода топ-10\n",
            "        embed = disnake.Embed(\n",
            "            title=\"🏆 Топ 10 участников по активности за сегодняшний день\",\n",
            "            description=f\"Дата: {today}\",\n",
            "            color=disnake.Color.gold()\n",
            "        )\n",
            "\n",
            "        # Заполнение данных по каждому участнику с использованием имён и упоминаний в значениях\n",
            "        for index, (user_id, message_count) in enumerate(top_10_users, start=1):\n",
            "            user = await self.bot.fetch_user(int(user_id))\n",
            "            mention = f\"<@{user_id}>\"\n",
            "            embed.add_field(\n",
            "                name=f\"{index}. {user.display_name}\",\n",
            "                value=f\"{mention} — Сообщений: {message_count}\",\n",
            "                inline=False\n",
            "            )\n",
            "\n",
            "        # Установка изображения для embed из config.json\n",
            "        embed.set_image(url=config[\"ACTIVITY_DAY_IMAGE\"])\n",
            "\n",
            "        embed.set_footer(text=\"Статистика обновляется в реальном времени.\")\n",
            "        await inter.send(embed=embed)\n",
            "\n",
            "    @tasks.loop(time=time(0, 0))\n",
            "    async def reset_daily_activity(self):\n",
            "        # Очистка данных в полночь\n",
            "        self.daily_message_count = {}\n",
            "        self.save_activity_data()\n",
            "        print(\"Данные активности сброшены и сохранены в 00:00.\")\n",
            "\n",
            "    @reset_daily_activity.before_loop\n",
            "    async def before_reset(self):\n",
            "        await self.bot.wait_until_ready()\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(ServerActivity(bot))\n"
        ]
    },
    "user_func/color_picker.py": {
        "hash": "a1d75a1495af815e55bd4e46f8ccba41",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "import random\n",
            "\n",
            "class ColorPicker(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "\n",
            "    @commands.slash_command(name=\"color_picker\", description=\"Генерация случайного цвета\")\n",
            "    async def color_picker(self, inter: disnake.ApplicationCommandInteraction):\n",
            "        \"\"\"Генерирует случайный цвет и отображает его.\"\"\"\n",
            "        random_color = random.randint(0, 0xFFFFFF)  # Генерация случайного цвета\n",
            "        embed = disnake.Embed(\n",
            "            title=\"Случайный цвет\",\n",
            "            description=f\"Выпал цвет: #{random_color:06X}\",\n",
            "            color=random_color\n",
            "        )\n",
            "        await inter.response.send_message(embed=embed)\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(ColorPicker(bot))\n"
        ]
    },
    "user_func/engagement.py": {
        "hash": "a3ca8454168720024898f61537409064",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from datetime import datetime, timedelta\n",
            "import pytz  # Для работы с временными зонами\n",
            "import os  # Для работы с файловой системой\n",
            "import json  # Для работы с JSON файлами\n",
            "\n",
            "class ServerEngagement(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        self.engagement_data = self.load_engagement_data()\n",
            "        self.save_engagement_data()\n",
            "        with open(\"conf/config.json\", \"r\") as f:\n",
            "            self.config = json.load(f)\n",
            "\n",
            "    def load_engagement_data(self):\n",
            "        if os.path.exists(\"data/engagement_data.json\"):\n",
            "            try:\n",
            "                with open(\"data/engagement_data.json\", \"r\") as f:\n",
            "                    return json.load(f)\n",
            "            except json.JSONDecodeError:\n",
            "                print(\"Файл engagement_data.json пуст или повреждён. Инициализация пустого словаря.\")\n",
            "                return {}\n",
            "        return {\n",
            "            'messages_sent': 0,\n",
            "            'polls_created': 0,\n",
            "            'poll_participants': 0,\n",
            "            'reactions_sent': 0,\n",
            "            'new_members': 0\n",
            "        }\n",
            "\n",
            "    def save_engagement_data(self):\n",
            "        with open(\"data/engagement_data.json\", \"w\") as f:\n",
            "            json.dump(self.engagement_data, f)\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_message(self, message: disnake.Message):\n",
            "        if message.author == self.bot.user or message.author.bot:\n",
            "            return\n",
            "        \n",
            "        self.engagement_data['messages_sent'] += 1\n",
            "        \n",
            "        # Приводим datetime.now() к временной зоне UTC\n",
            "        utc_now = datetime.now(pytz.utc)\n",
            "\n",
            "        self.save_engagement_data()\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_reaction_add(self, reaction: disnake.Reaction, user: disnake.User):\n",
            "        if user == self.bot.user:\n",
            "            return\n",
            "\n",
            "        self.engagement_data['reactions_sent'] += 1\n",
            "        self.save_engagement_data()\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_member_join(self, member: disnake.Member):\n",
            "        if member.joined_at and datetime.now(pytz.utc) - member.joined_at <= timedelta(days=30):\n",
            "            self.engagement_data['new_members'] += 1\n",
            "        self.save_engagement_data()\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_poll_create(self, poll):  \n",
            "        self.engagement_data['polls_created'] += 1\n",
            "        self.save_engagement_data()\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_poll_participation(self, participant):  \n",
            "        self.engagement_data['poll_participants'] += 1\n",
            "        self.save_engagement_data()\n",
            "\n",
            "    @commands.slash_command(description=\"Показать общую вовлечённость сервера.\")\n",
            "    async def server_engagement(self, inter: disnake.ApplicationCommandInteraction):\n",
            "        embed = disnake.Embed(\n",
            "            title=\"📊 Вовлечённость сервера\",\n",
            "            description=f\"Данные по вовлечённости на сервере на {datetime.now().strftime('%Y-%m-%d')}\",\n",
            "            color=disnake.Color.gold()\n",
            "        )\n",
            "\n",
            "        embed.set_image(url=self.config[\"ENGAGEMENT_IMAGE\"])\n",
            "\n",
            "        embed.add_field(\n",
            "            name=\"💬 Сообщения\",\n",
            "            value=f\"Общее количество сообщений: {self.engagement_data['messages_sent']}\",\n",
            "            inline=False\n",
            "        )\n",
            "        embed.add_field(\n",
            "            name=\"📊 Голосования\",\n",
            "            value=f\"Количество голосований: {self.engagement_data['polls_created']}\",\n",
            "            inline=False\n",
            "        )\n",
            "        embed.add_field(\n",
            "            name=\"🙋‍♂️ Участники опросов\",\n",
            "            value=f\"Количество участников опросов: {self.engagement_data['poll_participants']}\",\n",
            "            inline=False\n",
            "        )\n",
            "        embed.add_field(\n",
            "            name=\"❤️ Реакции\",\n",
            "            value=f\"Общее количество реакций: {self.engagement_data['reactions_sent']}\",\n",
            "            inline=False\n",
            "        )\n",
            "        embed.add_field(\n",
            "            name=\"🆕 Новые участники за месяц\",\n",
            "            value=f\"Новых участников: {self.engagement_data['new_members']}\",\n",
            "            inline=False\n",
            "        )\n",
            "\n",
            "        if self.engagement_data['messages_sent'] > 0:\n",
            "            avg_messages_per_day = self.engagement_data['messages_sent'] / (datetime.now().day)\n",
            "            embed.add_field(\n",
            "                name=\"📈 Среднее количество сообщений на пользователя за день\",\n",
            "                value=f\"{avg_messages_per_day:.2f}\",\n",
            "                inline=False\n",
            "            )\n",
            "\n",
            "        embed.set_footer(text=\"Статистика обновляется в реальном времени.\")\n",
            "        await inter.send(embed=embed)\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(ServerEngagement(bot))\n"
        ]
    },
    "user_func/history.py": {
        "hash": "5e6cda1bbc935a9ef57863e87217ab60",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "import random\n",
            "\n",
            "class History(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        self.questions = [\n",
            "            \"Кто главный герой? (Введите имя в именительном падеже, например: +Иван):\",\n",
            "            \"Где всё происходит? (Введите место в предложном падеже с предлогом 'в/на', например: +в парке):\", \n",
            "            \"Когда это было? (Введите время в предложном падеже, например: +тёплым утром):\",\n",
            "            \"Какая была погода? (Введите в именительном падеже, например: +солнечная погода):\",\n",
            "            \"Какое событие произошло? (Введите в прошедшем времени, например: +произошла неожиданная встреча):\",\n",
            "            \"Кого встретил герой? (Введите в винительном падеже, например: +старого друга):\",\n",
            "            \"Что сделал герой после встречи? (Введите в прошедшем времени, например: +отправился на прогулку):\",\n",
            "            \"Куда направились герои? (Введите в винительный падеже с предлогом, например: +в кафе):\",\n",
            "            \"Что они там обнаружили? (Введите в винительном падеже, например: +интересную книгу):\",\n",
            "            \"Какое препятствие встретили? (Введите в именительном падеже, например: +сложная ситуация):\",\n",
            "            \"Как справились с ситуацией? (Введите в прошедшем времени, например: +нашли общий язык):\",\n",
            "            \"Кто помог героям? (Введите в именительном падеже, например: +случайный прохожий):\",\n",
            "            \"Что важное приобрели? (Введите в винительном падеже, например: +новый опыт):\",\n",
            "            \"Какое открытие сделали? (Введите в винительном падеже, например: +важный урок):\",\n",
            "            \"Чем всё закончилось? (Введите полным предложением, например: +Герои стали хорошими друзьями):\",\n",
            "            \"Что помогло в пути? (Введите в именительном падеже, например: +карта местности):\",\n",
            "            \"Какой навык пригодился? (Введите в именительном падеже, например: +знание языков):\",\n",
            "            \"Какую трудность преодолели? (Введите в винительном падеже, например: +языковой барьер):\",\n",
            "            \"Какую пользу получили? (Введите в винительном падеже, например: +ценный совет):\",\n",
            "            \"Какой вывод сделали? (Введите полным предложением, например: +Поняли важность взаимопомощи):\"\n",
            "        ]\n",
            "        self.answers = {}\n",
            "        self.story_templates = [\n",
            "            \"Однажды {2} {1} жил-был {0}. Стояла {3}, создавая идеальную атмосферу для начала истории.\\n\\nВсё началось с того, что {4}. Это событие изменило привычный уклад жизни и открыло новую страницу. У героя была с собой необычная вещь – {15}, что очень пригодилось позже.\\n\\nВ начале пути герой встретил {5}. Эта встреча оказалась очень важной для дальнейших событий. Герою пригодился уникальный навык {16}, что помогло лучше понять ситуацию.\\n\\nПосле этой встречи {0} {6}. Каждое решение приближало к намеченной цели. По пути героям пришлось преодолеть {17}, что сделало их сильнее.\\n\\nИх путь привёл их {7}, где они неожиданно обнаружили {8}. Это открытие заставило посмотреть на всё другими глазами.\\n\\nНо возникло препятствие – {9}. Казалось, что ситуация безвыходная, но герои {10}. За проявленную находчивость они получили {18}, что оказалось очень полезным.\\n\\nВ нужный момент появился {11}, чья помощь оказалась неоценимой. Вместе они приобрели {12}, что открыло новые возможности.\\n\\nБлагодаря этому они поняли {13}. Всё начало складываться в единую картину. {19}, и это стало важным этапом развития.\\n\\n{14}\\n\\n*Эта история учит нас тому, что каждая встреча и каждое событие могут изменить нашу жизнь. Главное – быть открытым новому опыту и не бояться трудностей на своём пути.*\",\n",
            "\n",
            "            \"Однажды {2} {1} началась эта необычная история. Главным героем стал {0}, которому предстояло пережить интересные события. При себе у него был необычный предмет – {15}, который сыграл важную роль.\\n\\nСтояла {3}, что создавало особое настроение. В этот день {4}, что послужило началом целой череды событий. Отточенный навык – {16} – помог лучше разобраться в происходящем.\\n\\nВ ходе событий герой встретил {5}, что оказалось важным поворотным моментом. Вместе они столкнулись со сложным препятствием – {17}, но смогли найти решение.\\n\\nПосле этого {0} {6}. Каждый новый шаг приносил героям новые открытия, а {18} стал наградой за настойчивость.\\n\\nПуть привёл их {7}, где они обнаружили {8}. Это заставило взглянуть на ситуацию по-новому.\\n\\nНеожиданно возникло препятствие – {9}. В этой ситуации герои {10}. {19}, что стало важным уроком для всех.\\n\\nСвоевременно {11} предложил помощь. Благодаря совместным усилиям они получили {12}, что оказалось очень кстати.\\n\\nЭто привело к важному открытию – {13}. Все детали сложились в единую картину, помогая понять суть происходящего.\\n\\n{14}\\n\\n*Эта история показывает, как важно быть внимательным к деталям и открытым к новым возможностям. Иногда самые обычные ситуации могут привести к удивительным результатам.*\"\n",
            "        ]\n",
            "        \n",
            "    @commands.slash_command()\n",
            "    async def history(self, inter: disnake.ApplicationCommandInteraction):\n",
            "        \"\"\"Создает интерактивную историю на основе ваших ответов\"\"\"\n",
            "        self.answers[inter.channel.id] = []\n",
            "        \n",
            "        await inter.response.send_message(\"Давайте создадим историю вместе! Я задам несколько вопросов. Отвечайте на вопросы, начиная ответ со знака '+'\")\n",
            "        \n",
            "        for question in self.questions:\n",
            "            message = await inter.channel.send(question)\n",
            "            \n",
            "            while True:\n",
            "                try:\n",
            "                    response = await self.bot.wait_for(\n",
            "                        \"message\",\n",
            "                        timeout=300.0,\n",
            "                        check=lambda m: m.channel == inter.channel\n",
            "                    )\n",
            "                    \n",
            "                    if response.content.startswith(\"+\"):\n",
            "                        answer = response.content[1:].strip()\n",
            "                        self.answers[inter.channel.id].append(answer)\n",
            "                        await response.add_reaction(\"✅\")\n",
            "                        break\n",
            "                    else:\n",
            "                        await response.add_reaction(\"❌\")\n",
            "                        await inter.channel.send(\"Ответ должен начинаться со знака '+'. Попробуйте ещё раз.\")\n",
            "                        \n",
            "                except TimeoutError:\n",
            "                    await inter.channel.send(\"Время ожидания истекло. Попробуйте начать заново.\")\n",
            "                    return\n",
            "                \n",
            "        story_template = random.choice(self.story_templates)\n",
            "        answers = self.answers[inter.channel.id]\n",
            "        \n",
            "        story = story_template.format(*answers)\n",
            "        \n",
            "        embed = disnake.Embed(\n",
            "            title=\"✨ Ваша уникальная история ✨\",\n",
            "            description=story,\n",
            "            color=disnake.Color.gold()\n",
            "        )\n",
            "        embed.set_footer(text=\"Создано с помощью силы воображения ✨\")\n",
            "        await inter.channel.send(embed=embed)\n",
            "        del self.answers[inter.channel.id]\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(History(bot))\n"
        ]
    },
    "user_func/invite_leaderboard.py": {
        "hash": "c8f74cf1bf98cb796df273b261806af4",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "import json\n",
            "\n",
            "class ServerInviteLeaderboard(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        with open('conf/config.json', 'r', encoding='utf-8') as f:\n",
            "            self.config = json.load(f)\n",
            "\n",
            "    async def get_invite_data(self):\n",
            "        invite_data = {}\n",
            "\n",
            "        for invite in await self.bot.guilds[0].invites():\n",
            "            inviter_id = str(invite.inviter.id)\n",
            "            if invite.uses > 0:\n",
            "                if inviter_id not in invite_data:\n",
            "                    invite_data[inviter_id] = 0\n",
            "                invite_data[inviter_id] += invite.uses\n",
            "\n",
            "        sorted_invite_data = sorted(invite_data.items(), key=lambda x: x[1], reverse=True)\n",
            "        return sorted_invite_data\n",
            "\n",
            "    @commands.slash_command(description=\"Показать топ участников по количеству приглашений.\")\n",
            "    async def server_invite_leaderboard(self, inter: disnake.ApplicationCommandInteraction):\n",
            "        await inter.response.defer()  # Отправляем defer, чтобы избежать тайм-аута\n",
            "\n",
            "        invite_data = await self.get_invite_data()\n",
            "\n",
            "        if not invite_data:\n",
            "            await inter.edit_original_message(content=\"На сервере пока нет данных о приглашениях.\")\n",
            "            return\n",
            "\n",
            "        embed = disnake.Embed(\n",
            "            title=\"🏆 Топ участников по приглашениям\",\n",
            "            description=\"Топ участников, пригласивших больше всего людей на сервер!\",\n",
            "            color=disnake.Color.gold()\n",
            "        )\n",
            "        embed.set_image(url=self.config[\"INVITE_IMAGE\"])\n",
            "        \n",
            "        # Добавляем аватарку сервера в footer\n",
            "        server_icon = inter.guild.icon.url if inter.guild.icon else None\n",
            "        embed.set_footer(text=\"Спасибо за вклад в рост нашего сообщества!\", icon_url=server_icon)\n",
            "\n",
            "        for index, (user_id, invite_count) in enumerate(invite_data[:10], start=1):\n",
            "            user = await self.bot.fetch_user(int(user_id))\n",
            "            embed.add_field(\n",
            "                name=f\"{index}. {user.display_name} 🎉\",\n",
            "                value=f\"Приглашений: {invite_count} \",\n",
            "                inline=False\n",
            "            )\n",
            "\n",
            "        await inter.edit_original_message(embed=embed)\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(ServerInviteLeaderboard(bot))\n"
        ]
    },
    "user_func/level.py": {
        "hash": "f101372dce69baa3d7ea0521fb62bb22",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from disnake import Embed\n",
            "import os\n",
            "import json\n",
            "\n",
            "class UserLevel(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        # Путь к файлу с данными пользователей\n",
            "        self.base_path = os.path.dirname(os.path.abspath(__file__))  # Путь до server_func\n",
            "        self.file_path = os.path.join(self.base_path, \"../data/member_level.json\")  # В папку data\n",
            "\n",
            "    def read_data(self):\n",
            "        \"\"\"Чтение данных из JSON.\"\"\"\n",
            "        with open(self.file_path, \"r\") as file:\n",
            "            return json.load(file)\n",
            "\n",
            "    @commands.slash_command(name=\"level\", description=\"Получить информацию о текущем уровне пользователя\")\n",
            "    async def level(self, interaction: disnake.ApplicationCommandInteraction, member: disnake.Member = None):\n",
            "        \"\"\"Отображает уровень участника или вызывающего команду.\"\"\"\n",
            "\n",
            "        # Если участник не выбран, то используем автора команды\n",
            "        if not member:\n",
            "            member = interaction.user\n",
            "\n",
            "        # Получаем данные о пользователе из JSON\n",
            "        data = self.read_data()\n",
            "        user_data = data.get(str(member.id))\n",
            "\n",
            "        # Если пользователь не найден в базе, то создаем его\n",
            "        if not user_data:\n",
            "            await interaction.response.send_message(f\"{member.mention} еще не имеет данных о уровне.\", ephemeral=True)\n",
            "            return\n",
            "\n",
            "        level = user_data[\"level\"]\n",
            "        xp = user_data[\"xp\"]\n",
            "        # Квадратичное увеличение опыта\n",
            "        level_up_xp = 100 * (level ** 2)  # Базовое количество XP для следующего уровня\n",
            "\n",
            "        xp_needed = level_up_xp - xp  # Необходимый опыт для следующего уровня\n",
            "        progress = xp / level_up_xp  # Процент заполненности шкалы XP\n",
            "\n",
            "        # Создаем Embed\n",
            "        embed = Embed(\n",
            "            title=f\"Статистика участника\",\n",
            "            description=f\"Информация о текущем уровне {member.mention}\",\n",
            "            color=disnake.Color.blurple()\n",
            "        )\n",
            "\n",
            "        # Добавляем поля с уровнем и опытом\n",
            "        embed.add_field(name=\"💎 Текущий уровень\", value=level, inline=False)\n",
            "        embed.add_field(name=\"⚡ Текущий опыт\", value=f\"{xp} XP\", inline=False)\n",
            "        embed.add_field(name=\"⚡ Необходимый опыт для следующего уровня\", value=f\"{xp_needed} XP\", inline=False)\n",
            "\n",
            "        # Создаем ползунок XP\n",
            "        progress_bar = self.create_xp_bar(progress)\n",
            "        embed.add_field(name=\"🔋 Прогресс\", value=progress_bar, inline=False)\n",
            "\n",
            "        # Добавляем footer с информацией о том, кто запросил команду\n",
            "        embed.set_footer(\n",
            "            text=f\"Запрашивает: {interaction.user.display_name}\", \n",
            "            icon_url=interaction.user.avatar.url if interaction.user.avatar else None\n",
            "        )\n",
            "\n",
            "        # Отправляем Embed\n",
            "        await interaction.response.send_message(embed=embed)\n",
            "\n",
            "    def create_xp_bar(self, progress):\n",
            "        \"\"\"Создание визуального ползунка XP в виде строки.\"\"\"\n",
            "        total_length = 20  # Длина ползунка\n",
            "        filled_length = int(total_length * progress)  # Заполненная часть\n",
            "        bar = \"█\" * filled_length + \"▒\" * (total_length - filled_length)  # Ползунок\n",
            "        return bar\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(UserLevel(bot))\n"
        ]
    },
    "user_func/level_leaderboard.py": {
        "hash": "afccbfef3303d357a453b5c5dc3c076b",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "import json\n",
            "from pathlib import Path\n",
            "\n",
            "\n",
            "class LevelLeaderboard(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        self.data_file = Path(\"data/member_level.json\")\n",
            "\n",
            "    def load_level_data(self):\n",
            "        if self.data_file.exists():\n",
            "            with open(self.data_file, \"r\", encoding=\"utf-8\") as file:\n",
            "                return json.load(file)\n",
            "        return {}\n",
            "\n",
            "    def generate_leaderboard_page(self, sorted_members, ctx, page=1, per_page=10):\n",
            "        start_index = (page - 1) * per_page\n",
            "        end_index = start_index + per_page\n",
            "\n",
            "        filtered_members = [\n",
            "            (member_id, stats)\n",
            "            for member_id, stats in sorted_members\n",
            "            if ctx.guild.get_member(int(member_id)) is not None\n",
            "        ]\n",
            "\n",
            "        leaderboard_text = \"\"\n",
            "        for index, (member_id, stats) in enumerate(filtered_members[start_index:end_index], start=start_index + 1):\n",
            "            member = ctx.guild.get_member(int(member_id))\n",
            "            member_tag = member.mention\n",
            "            leaderboard_text += f\"**{index}. {member_tag}** Уровень: {stats['level']}\\n\"\n",
            "\n",
            "        return leaderboard_text if leaderboard_text else \"Нет данных для отображения.\"\n",
            "\n",
            "    @commands.slash_command()\n",
            "    async def level_leaderboard(self, ctx: disnake.ApplicationCommandInteraction):\n",
            "        level_data = self.load_level_data()\n",
            "        sorted_members = sorted(level_data.items(), key=lambda item: item[1].get(\"level\", 0), reverse=True)\n",
            "\n",
            "        if not sorted_members:\n",
            "            await ctx.send(embed=disnake.Embed(description=\"❌ Нет данных для отображения.\", color=disnake.Color.red()), ephemeral=True)\n",
            "            return\n",
            "\n",
            "        page = 1\n",
            "        embed = disnake.Embed(\n",
            "            title=\"📋 Таблица лидеров по уровням\",\n",
            "            description=self.generate_leaderboard_page(sorted_members, ctx, page),\n",
            "            color=disnake.Color.gold()\n",
            "        )\n",
            "        embed.set_footer(text=f\"Страница {page}/{(len(sorted_members) - 1) // 10 + 1}\")\n",
            "\n",
            "        # Создаем действия для кнопок\n",
            "        buttons = disnake.ui.ActionRow(\n",
            "            disnake.ui.Button(label=\"⬅\", style=disnake.ButtonStyle.primary, custom_id=\"leaderboard_prev_page\"),\n",
            "            disnake.ui.Button(label=\"⏸\", style=disnake.ButtonStyle.secondary, custom_id=\"leaderboard_stop\"),\n",
            "            disnake.ui.Button(label=\"➡\", style=disnake.ButtonStyle.primary, custom_id=\"leaderboard_next_page\")\n",
            "        )\n",
            "\n",
            "        # Создаем View, который будет управлять кнопками в пределах этого конкретного сообщения\n",
            "        view = LevelLeaderboardView(sorted_members, ctx, embed, page)\n",
            "\n",
            "        message = await ctx.send(embed=embed, view=view)  # Используем только view, без components\n",
            "\n",
            "\n",
            "class LevelLeaderboardView(disnake.ui.View):\n",
            "    def __init__(self, sorted_members, ctx, embed, page):\n",
            "        super().__init__(timeout=180.0)\n",
            "        self.sorted_members = sorted_members\n",
            "        self.ctx = ctx\n",
            "        self.embed = embed\n",
            "        self.page = page\n",
            "\n",
            "    @disnake.ui.button(label=\"⬅\", style=disnake.ButtonStyle.primary, custom_id=\"leaderboard_prev_page\")\n",
            "    async def prev_page(self, button: disnake.ui.Button, inter: disnake.MessageInteraction):\n",
            "        if inter.author != self.ctx.author:\n",
            "            await inter.response.send_message(\"Вы не можете управлять этой таблицей!\", ephemeral=True)\n",
            "            return\n",
            "        self.page = max(1, self.page - 1)\n",
            "        self.embed.description = self.generate_leaderboard_page(self.sorted_members, self.ctx, self.page)\n",
            "        self.embed.set_footer(text=f\"Страница {self.page}/{(len(self.sorted_members) - 1) // 10 + 1}\")\n",
            "        await inter.response.edit_message(embed=self.embed, view=self)\n",
            "\n",
            "    @disnake.ui.button(label=\"⏸\", style=disnake.ButtonStyle.secondary, custom_id=\"leaderboard_stop\")\n",
            "    async def stop(self, button: disnake.ui.Button, inter: disnake.MessageInteraction):\n",
            "        if inter.author != self.ctx.author:\n",
            "            await inter.response.send_message(\"Вы не можете управлять этой таблицей!\", ephemeral=True)\n",
            "            return\n",
            "        await inter.response.defer()\n",
            "\n",
            "    @disnake.ui.button(label=\"➡\", style=disnake.ButtonStyle.primary, custom_id=\"leaderboard_next_page\")\n",
            "    async def next_page(self, button: disnake.ui.Button, inter: disnake.MessageInteraction):\n",
            "        if inter.author != self.ctx.author:\n",
            "            await inter.response.send_message(\"Вы не можете управлять этой таблицей!\", ephemeral=True)\n",
            "            return\n",
            "        self.page = min((len(self.sorted_members) - 1) // 10 + 1, self.page + 1)\n",
            "        self.embed.description = self.generate_leaderboard_page(self.sorted_members, self.ctx, self.page)\n",
            "        self.embed.set_footer(text=f\"Страница {self.page}/{(len(self.sorted_members) - 1) // 10 + 1}\")\n",
            "        await inter.response.edit_message(embed=self.embed, view=self)\n",
            "\n",
            "    def generate_leaderboard_page(self, sorted_members, ctx, page=1, per_page=10):\n",
            "        start_index = (page - 1) * per_page\n",
            "        end_index = start_index + per_page\n",
            "\n",
            "        filtered_members = [\n",
            "            (member_id, stats)\n",
            "            for member_id, stats in sorted_members\n",
            "            if ctx.guild.get_member(int(member_id)) is not None\n",
            "        ]\n",
            "\n",
            "        leaderboard_text = \"\"\n",
            "        for index, (member_id, stats) in enumerate(filtered_members[start_index:end_index], start=start_index + 1):\n",
            "            member = ctx.guild.get_member(int(member_id))\n",
            "            member_tag = member.mention\n",
            "            leaderboard_text += f\"**{index}. {member_tag}** Уровень: {stats['level']}\\n\"\n",
            "\n",
            "        return leaderboard_text if leaderboard_text else \"Нет данных для отображения.\"\n",
            "\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(LevelLeaderboard(bot))\n"
        ]
    },
    "user_func/profile.py": {
        "hash": "b545ef44823eaa7d16e9d01f988040ae",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from disnake import Embed\n",
            "import json\n",
            "import os\n",
            "\n",
            "class ServerMemberInfo(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        # Путь к файлу с данными пользователей\n",
            "        self.base_path = os.path.dirname(os.path.abspath(__file__))  # Путь до server_func\n",
            "        self.file_path = os.path.join(self.base_path, \"../data/member_level.json\")  # В папку data\n",
            "\n",
            "    def read_data(self):\n",
            "        \"\"\"Чтение данных из JSON.\"\"\"\n",
            "        with open(self.file_path, \"r\") as file:\n",
            "            return json.load(file)\n",
            "\n",
            "    @commands.slash_command(name=\"user_member_info\", description=\"Получить подробную информацию о участнике\")\n",
            "    async def server_member_info(self, interaction: disnake.ApplicationCommandInteraction, member: disnake.Member):\n",
            "        \"\"\"Отправляет embed с подробной информацией о пользователе и его ролях в обратном порядке.\"\"\"\n",
            "        \n",
            "        # Форматируем время присоединения\n",
            "        joined_at = member.joined_at.strftime(\"%Y-%m-%d %H:%M:%S\")\n",
            "        created_at = member.created_at.strftime(\"%Y-%m-%d %H:%M:%S\")\n",
            "\n",
            "        # Получаем роли участника в обратном порядке\n",
            "        roles = [role.mention for role in reversed(member.roles) if role != interaction.guild.default_role]\n",
            "        roles = roles if roles else [\"Нет ролей\"]\n",
            "\n",
            "        # Попробуем получить баннер через fetch_member\n",
            "        try:\n",
            "            fetched_member = await interaction.guild.fetch_member(member.id)  # Загружаем полные данные\n",
            "\n",
            "            # Проверяем, есть ли баннер\n",
            "            if fetched_member.banner:\n",
            "                banner_url = fetched_member.banner.url  # Получаем URL баннера\n",
            "            else:\n",
            "                banner_url = None\n",
            "        except Exception as e:\n",
            "            print(f\"Ошибка при получении данных о баннере для {member.display_name}: {e}\")\n",
            "            banner_url = None  # Если возникла ошибка, установим баннер как None\n",
            "\n",
            "        # Делаем defer, чтобы отложить ответ\n",
            "        await interaction.response.defer()\n",
            "\n",
            "        # Получаем данные из JSON о пользователе\n",
            "        data = self.read_data()\n",
            "        user_data = data.get(str(member.id))\n",
            "        \n",
            "        # Устанавливаем информацию о уровне и опыте (если пользователь есть в данных)\n",
            "        level = user_data[\"level\"] if user_data else \"Не доступно\"\n",
            "        xp = user_data[\"xp\"] if user_data else \"Не доступно\"\n",
            "\n",
            "        # Создаем Embed сообщение\n",
            "        embed = Embed(\n",
            "            title=f\"Информация о участнике {member.display_name}\",\n",
            "            description=f\"Информация о пользователе {member.mention}\",\n",
            "            color=disnake.Color.blurple()\n",
            "        )\n",
            "\n",
            "        # Добавляем баннер, если он есть\n",
            "        if banner_url:\n",
            "            embed.set_image(url=banner_url)  # Если баннер существует, показываем его\n",
            "        else:\n",
            "            embed.set_image(url=None)  # Если нет баннера, ничего не выводим\n",
            "\n",
            "        # Добавляем аватар пользователя\n",
            "        embed.set_thumbnail(url=member.avatar.url)\n",
            "\n",
            "        # Добавляем дополнительные поля\n",
            "        embed.add_field(name=\"🆔 ID\", value=member.id, inline=False)\n",
            "        embed.add_field(name=\"📅 Присоединился\", value=joined_at, inline=False)\n",
            "        embed.add_field(name=\"📅 Создан\", value=created_at, inline=False)\n",
            "        embed.add_field(name=\"💎 Уровень\", value=level, inline=False)\n",
            "        embed.add_field(name=\"⚡ Опыт\", value=f\"{xp} XP\", inline=False)\n",
            "\n",
            "        # Роли добавляем последним\n",
            "        embed.add_field(name=\"👥 Роли\", value=\" \".join(roles), inline=False)\n",
            "\n",
            "        # Отправляем Embed\n",
            "        await interaction.edit_original_response(embed=embed)\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(ServerMemberInfo(bot))\n"
        ]
    },
    "user_func/reaction_leaderboard.py": {
        "hash": "3f3f4d7ce320d5254417a24d454258e0",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "from collections import Counter\n",
            "import json\n",
            "import os\n",
            "\n",
            "class ServerReactionTop(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        self.base_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n",
            "        self.config_path = os.path.join(self.base_path, \"conf/config.json\")\n",
            "        self.data_path = os.path.join(self.base_path, \"data/reaction_data.json\")\n",
            "        with open(self.config_path, 'r') as f:\n",
            "            self.config = json.load(f)\n",
            "        self.reaction_data = self.load_reaction_data()\n",
            "        self.save_reaction_data()\n",
            "\n",
            "    def load_reaction_data(self):\n",
            "        \"\"\"Загружаем или инициализируем данные по реакциям\"\"\"\n",
            "        if os.path.exists(self.data_path):\n",
            "            try:\n",
            "                with open(self.data_path, \"r\") as f:\n",
            "                    return json.load(f)\n",
            "            except json.JSONDecodeError:\n",
            "                print(\"Файл reaction_data.json пуст или повреждён. Инициализация пустого словаря.\")\n",
            "                return {}\n",
            "        return {}\n",
            "\n",
            "    def save_reaction_data(self):\n",
            "        \"\"\"Сохраняем данные по реакциям в файл\"\"\"\n",
            "        with open(self.data_path, \"w\") as f:\n",
            "            json.dump(self.reaction_data, f)\n",
            "\n",
            "    @commands.Cog.listener()\n",
            "    async def on_reaction_add(self, reaction: disnake.Reaction, user: disnake.User):\n",
            "        \"\"\"Отслеживаем реакции, добавляем их в данные\"\"\"\n",
            "        if user.bot:\n",
            "            return  # Игнорируем ботов\n",
            "        \n",
            "        user_id = str(user.id)\n",
            "        if user_id not in self.reaction_data:\n",
            "            self.reaction_data[user_id] = 0\n",
            "        self.reaction_data[user_id] += 1\n",
            "\n",
            "        self.save_reaction_data()\n",
            "\n",
            "    @commands.slash_command(description=\"Показать топ участников по реакциям.\")\n",
            "    async def server_reaction_top(self, inter: disnake.ApplicationCommandInteraction):\n",
            "        \"\"\"Отображаем топ-участников по количеству реакций\"\"\"\n",
            "        # Сортируем пользователей по количеству реакций\n",
            "        sorted_users = sorted(self.reaction_data.items(), key=lambda x: x[1], reverse=True)\n",
            "        top_users = sorted_users[:10]\n",
            "        \n",
            "        embed = disnake.Embed(\n",
            "            title=\"🏆 Топ участников по реакциям\",\n",
            "            description=f\"Топ-реактивных пользователей на сервере на {disnake.utils.format_dt(disnake.utils.utcnow(), 'D')}\",\n",
            "            color=disnake.Color.gold()\n",
            "        )\n",
            "\n",
            "        embed.set_image(url=self.config[\"REACTION_TOP_IMAGE\"])\n",
            "\n",
            "        if top_users:\n",
            "            for idx, (user_id, reactions) in enumerate(top_users, start=1):\n",
            "                user = await self.bot.fetch_user(user_id)\n",
            "                # Форматирование текста с никнеймом, пингом и количеством реакций\n",
            "                embed.add_field(\n",
            "                    name=f\"{idx}. {user.display_name}\",\n",
            "                    value=f\"{user.mention} - Реакций: {reactions} \",\n",
            "                    inline=False\n",
            "                )\n",
            "        else:\n",
            "            embed.add_field(\n",
            "                name=\"Нет данных\",\n",
            "                value=\"Пока никто не поставил реакции.\",\n",
            "                inline=False\n",
            "            )\n",
            "\n",
            "        embed.set_footer(text=\"Статистика обновляется в реальном времени.\")\n",
            "        await inter.send(embed=embed)\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(ServerReactionTop(bot))\n"
        ]
    },
    "user_func/roll.py": {
        "hash": "bc86b2a4836298dc96bb972761643f8d",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "import random\n",
            "\n",
            "class Roll(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "\n",
            "    @commands.slash_command(name=\"roll\", description=\"Бросить кубик и получить результат\")\n",
            "    async def roll(self, inter: disnake.ApplicationCommandInteraction):\n",
            "        \"\"\"Бросает виртуальный кубик и выводит результат.\"\"\"\n",
            "        roll_result = random.randint(1, 6)  # Кубик имеет 6 граней\n",
            "        embed = disnake.Embed(\n",
            "            title=\"Результат броска кубика!\",\n",
            "            description=f\"Вам выпало число: **{roll_result}**\",\n",
            "            color=disnake.Color.blue()\n",
            "        )\n",
            "        await inter.response.send_message(embed=embed)\n",
            "\n",
            "def setup(bot):\n",
            "    bot.add_cog(Roll(bot))\n"
        ]
    },
    "core/core.py": {
        "hash": "013845e07f17f04578e49b4f508a59d8",
        "content": [
            "import disnake\n",
            "from disnake.ext import commands\n",
            "import threading\n",
            "import os\n",
            "import json\n",
            "from pathlib import Path\n",
            "from colorama import Fore, Style, init\n",
            "import sys\n",
            "\n",
            "# Добавляем корневую директорию проекта в sys.path\n",
            "sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n",
            "\n",
            "# Устанавливаем заголовок окна\n",
            "os.system('title Bancho [Server Bandicoot]')\n",
            "\n",
            "# Инициализация colorama\n",
            "init()\n",
            "\n",
            "# Загружаем конфигурацию из JSON файла\n",
            "with open(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'conf/config.json'), 'r', encoding='utf-8') as f:\n",
            "    config = json.load(f)\n",
            "\n",
            "# Загружаем статус бота из JSON файла\n",
            "with open(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'conf/status.json'), 'r', encoding='utf-8') as f:\n",
            "    status_config = json.load(f)\n",
            "\n",
            "# Загружаем список папок с когами\n",
            "with open(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'conf/cogs.json'), 'r', encoding='utf-8') as f:\n",
            "    cogs_config = json.load(f)\n",
            "\n",
            "# Включаем все намерения для работы с контентом сообщений, пользователями и событиями\n",
            "intents = disnake.Intents.default()\n",
            "intents.message_content = True      # Включаем намерение для работы с контентом сообщений\n",
            "intents.members = True            # Для получения данных о членах сервера\n",
            "intents.reactions = True         # Для работы с реакциями на сообщения  \n",
            "intents.guilds = True           # Для работы с серверами\n",
            "\n",
            "# Указываем ID тестовой гильдии для быстрого тестирования слэш-команд\n",
            "bot = commands.Bot(\n",
            "    command_prefix=config['prefix'],\n",
            "    intents=intents,\n",
            "    test_guilds=[config['test_guild_id']]\n",
            ")\n",
            "\n",
            "# Функция для загрузки когов\n",
            "def load_cogs():\n",
            "    # Получаем путь к корневой директории проекта\n",
            "    root_dir = os.path.dirname(os.path.dirname(__file__))\n",
            "    \n",
            "    for folder in cogs_config['cog_folders']:\n",
            "        cogs_path = Path(os.path.join(root_dir, folder))\n",
            "        if not cogs_path.exists():\n",
            "            print(f\"{Fore.YELLOW}Папка {folder} не найдена{Style.RESET_ALL}\")\n",
            "            continue\n",
            "            \n",
            "        for cog_file in cogs_path.glob(\"*.py\"):\n",
            "            if cog_file.stem.startswith(\"_\"):\n",
            "                continue\n",
            "                \n",
            "            cog_name = f\"{folder}.{cog_file.stem}\"\n",
            "            try:\n",
            "                bot.load_extension(cog_name)\n",
            "                print(f\"{Fore.YELLOW}Загружен ког: {cog_name}{Style.RESET_ALL}\")\n",
            "            except Exception as e:\n",
            "                print(f\"{Fore.YELLOW}Ошибка при загрузке кога {cog_name}: {e}{Style.RESET_ALL}\")\n",
            "\n",
            "# Загрузка расширений ДО старта бота\n",
            "@bot.event\n",
            "async def on_ready():\n",
            "    print(f'{Fore.YELLOW}Мы подключились как {bot.user}{Style.RESET_ALL}')\n",
            "    \n",
            "    try:\n",
            "        # Загружаем коги\n",
            "        load_cogs()\n",
            "        \n",
            "        # Устанавливаем статус бота из конфигурации\n",
            "        activity = disnake.Activity(\n",
            "            type=getattr(disnake.ActivityType, status_config['type']), \n",
            "            name=status_config['name']\n",
            "        )\n",
            "        await bot.change_presence(activity=activity)\n",
            "\n",
            "        print(f\"{Fore.YELLOW}Команды синхронизированы успешно.{Style.RESET_ALL}\")\n",
            "    except Exception as e:\n",
            "        print(f\"{Fore.YELLOW}Ошибка при синхронизации команд: {e}{Style.RESET_ALL}\")\n",
            "\n",
            "# Запуск бота\n",
            "bot.run(config['token'])\n"
        ]
    },
    "./change_log.py": {
        "hash": "c00f09302ecec08bbfa30e1e592b758b",
        "content": [
            "import os\n",
            "import json\n",
            "from hashlib import md5\n",
            "from disnake import Embed, Color\n",
            "from disnake.ext import commands, tasks\n",
            "from datetime import datetime\n",
            "import difflib\n",
            "\n",
            "# Загрузка конфигурации\n",
            "with open('conf/config.json', 'r', encoding='utf-8') as f:\n",
            "    config = json.load(f)\n",
            "\n",
            "# Файл снапшота с хэшами и содержимым\n",
            "SNAPSHOT_FILE = \"data/cogs_snapshot.json\"\n",
            "MAX_FIELD_LENGTH = 1024  # Максимальная длина для одного поля в Embed\n",
            "\n",
            "\n",
            "class ChangeLog(commands.Cog):\n",
            "    def __init__(self, bot):\n",
            "        self.bot = bot\n",
            "        self.snapshot = self.load_snapshot()\n",
            "        self.check_changes.start()\n",
            "\n",
            "    def load_snapshot(self):\n",
            "        if os.path.exists(SNAPSHOT_FILE):\n",
            "            with open(SNAPSHOT_FILE, \"r\", encoding=\"utf-8\") as f:\n",
            "                return json.load(f)\n",
            "        else:\n",
            "            self.save_snapshot({})\n",
            "            return {}\n",
            "\n",
            "    def save_snapshot(self, snapshot):\n",
            "        with open(SNAPSHOT_FILE, \"w\", encoding=\"utf-8\") as f:\n",
            "            json.dump(snapshot, f, indent=4, ensure_ascii=False)\n",
            "\n",
            "    def calculate_file_hash(self, file_path):\n",
            "        with open(file_path, \"rb\") as f:\n",
            "            return md5(f.read()).hexdigest()\n",
            "\n",
            "    def get_file_content(self, file_path):\n",
            "        with open(file_path, \"r\", encoding=\"utf-8\") as f:\n",
            "            return f.readlines()\n",
            "\n",
            "    def get_current_state(self):\n",
            "        directories = [\n",
            "            \".\", \"admin_func\", \"dev_func\", \"event\",\n",
            "            \"news\", \"server_func\", \"user_func\",\n",
            "            \"core\", \"data\", \"conf\"\n",
            "        ]\n",
            "        state = {}\n",
            "        for directory in directories:\n",
            "            if os.path.exists(directory):\n",
            "                for filename in os.listdir(directory):\n",
            "                    if filename.endswith((\".py\", \".json\")):  # Добавляем отслеживание .json файлов\n",
            "                        file_path = os.path.join(directory, filename)\n",
            "                        if filename != SNAPSHOT_FILE:\n",
            "                            state[f\"{directory}/{filename}\"] = {\n",
            "                                \"hash\": self.calculate_file_hash(file_path),\n",
            "                                \"content\": self.get_file_content(file_path)\n",
            "                            }\n",
            "        return state\n",
            "\n",
            "    @tasks.loop(seconds=5)\n",
            "    async def check_changes(self):\n",
            "        current_state = self.get_current_state()\n",
            "        added, removed, modified = [], [], []\n",
            "        diffs = {}\n",
            "\n",
            "        for file_path, file_data in current_state.items():\n",
            "            if file_path not in self.snapshot:\n",
            "                added.append(file_path)\n",
            "            elif self.snapshot[file_path][\"hash\"] != file_data[\"hash\"]:\n",
            "                modified.append(file_path)\n",
            "                # Получаем различия между версиями файла\n",
            "                old_content = self.snapshot[file_path][\"content\"]\n",
            "                new_content = file_data[\"content\"]\n",
            "                diff = list(difflib.unified_diff(old_content, new_content, lineterm=''))\n",
            "                diffs[file_path] = diff\n",
            "\n",
            "        for file_path in self.snapshot:\n",
            "            if file_path not in current_state:\n",
            "                removed.append(file_path)\n",
            "\n",
            "        # Обновляем snapshot перед вызовом log_changes\n",
            "        for file_path, file_data in current_state.items():\n",
            "            self.snapshot[file_path] = file_data\n",
            "        for file_path in removed:\n",
            "            self.snapshot.pop(file_path, None)\n",
            "        self.save_snapshot(self.snapshot)\n",
            "\n",
            "        if added or removed or modified:\n",
            "            await self.log_changes(added, removed, modified, diffs)\n",
            "\n",
            "    async def log_changes(self, added, removed, modified, diffs):\n",
            "        current_time = datetime.now().strftime('%d.%m.%Y %H:%M')\n",
            "        \n",
            "        # Embed для добавленных файлов\n",
            "        added_embed = Embed(\n",
            "            title=\"ChangeLog - Добавленные файлы\",\n",
            "            description=\"Новые файлы в коде бота\",\n",
            "            color=Color.green()\n",
            "        )\n",
            "        added_embed.set_footer(text=f\"Дата и время: {current_time}\")\n",
            "\n",
            "        if added:\n",
            "            added_text = \"\\n\".join([f\"➕ {file}\" for file in added])\n",
            "            if len(added_text) <= MAX_FIELD_LENGTH:\n",
            "                added_embed.add_field(name=\"Созданные файлы\", value=f\"```diff\\n{added_text}\\n```\", inline=False)\n",
            "\n",
            "        # Embed для удаленных файлов\n",
            "        removed_embed = Embed(\n",
            "            title=\"ChangeLog - Удаленные файлы\",\n",
            "            description=\"Удаленные файлы из кода бота\",\n",
            "            color=Color.red()\n",
            "        )\n",
            "        removed_embed.set_footer(text=f\"Дата и время: {current_time}\")\n",
            "\n",
            "        if removed:\n",
            "            removed_text = \"\\n\".join([f\"➖ {file}\" for file in removed])\n",
            "            if len(removed_text) <= MAX_FIELD_LENGTH:\n",
            "                removed_embed.add_field(name=\"Удаленные файлы\", value=f\"```diff\\n{removed_text}\\n```\", inline=False)\n",
            "\n",
            "        # Отображение диффов в обоих embed'ах\n",
            "        if modified:\n",
            "            for file in modified:\n",
            "                if file in diffs:\n",
            "                    changes = []\n",
            "                    context_lines = 0\n",
            "                    for line in diffs[file]:\n",
            "                        if line.startswith('+') and not line.startswith('+++'):\n",
            "                            if context_lines > 0:\n",
            "                                changes.append('...')\n",
            "                                context_lines = 0\n",
            "                            changes.append(f\"➕ {line[1:]}\")\n",
            "                        elif line.startswith('-') and not line.startswith('---'):\n",
            "                            if context_lines > 0:\n",
            "                                changes.append('...')\n",
            "                                context_lines = 0\n",
            "                            changes.append(f\"➖ {line[1:]}\")\n",
            "                        else:\n",
            "                            context_lines += 1\n",
            "                            \n",
            "                    diff_text = \"\".join(changes)\n",
            "                    \n",
            "                    if len(diff_text) > MAX_FIELD_LENGTH - 50:\n",
            "                        diff_text = diff_text[:MAX_FIELD_LENGTH-60] + \"...(truncated)\"\n",
            "                    \n",
            "                    if diff_text:\n",
            "                        added_embed.add_field(\n",
            "                            name=f\"Изменения в {file}\",\n",
            "                            value=f\"```python\\n{diff_text}\\n```\",\n",
            "                            inline=False\n",
            "                        )\n",
            "\n",
            "        log_channel = self.bot.get_channel(config[\"LOG_CHANGE_COMMIT\"])\n",
            "        if log_channel:\n",
            "            if len(added_embed.fields) > 0:\n",
            "                await log_channel.send(embed=added_embed)\n",
            "            if len(removed_embed.fields) > 0:\n",
            "                await log_channel.send(embed=removed_embed)\n",
            "\n",
            "\n",
            "# Загрузка расширения\n",
            "def setup(bot):\n",
            "    bot.add_cog(ChangeLog(bot))\n"
        ]
    }
}